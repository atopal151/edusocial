import 'dart:async';
import 'dart:io';
import 'package:file_picker/file_picker.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';

import 'package:image_picker/image_picker.dart';
import '../../components/buttons/custom_button.dart';
import '../../models/chat_models/group_message_model.dart';
import '../../models/group_models/group_detail_model.dart';
import '../../models/document_model.dart';
import '../../models/link_model.dart';
import '../../services/group_services/group_service.dart';
import '../../services/language_service.dart';
import '../../services/socket_services.dart';
import '../../services/survey_service.dart';
import '../../services/pin_message_service.dart';
import '../profile_controller.dart';
import '../../components/snackbars/custom_snackbar.dart';

class GroupChatDetailController extends GetxController {
  // Services
  final GroupServices _groupServices = GroupServices();
  final LanguageService _languageService = Get.find<LanguageService>();

  final RxList<GroupMessageModel> messages = <GroupMessageModel>[].obs;
  final RxBool isLoading = false.obs;
  final RxBool isGroupDataLoading = false.obs; // Grup verisi i√ßin ayrƒ± loading
  final RxBool isMessagesLoading = false.obs; // Mesajlar i√ßin ayrƒ± loading
  final RxString currentGroupId = ''.obs;
  final groupData = Rx<GroupDetailModel?>(null);
  final TextEditingController messageController = TextEditingController();
  
  // Group chat i√ßin conversation ID mapping
  final RxString currentConversationId = ''.obs;

  // Socket service ile ilgili deƒüi≈ükenler
  late SocketService _socketService;
  late StreamSubscription _groupMessageSubscription;
  late StreamSubscription _pinMessageSubscription; // Pin message subscription eklendi

  bool _isSocketListenerSetup = false; // Multiple subscription guard
  final ScrollController scrollController = ScrollController();

  // PAGINATION: New state variables for lazy loading group messages
  final RxBool isLoadingMoreMessages = false.obs;
  final RxBool hasMoreMessages = true.obs;
  final RxInt currentOffset = 0.obs;
  final int messagesPerPage = 1000; // Increased from 25 to 1000 to remove limit
  final RxBool isFirstLoad = true.obs;
  
  // Track message count for auto-scroll optimization
  int _lastMessageCount = 0;
  
  // Scroll to bottom button visibility
  final RxBool showScrollToBottomButton = false.obs;

  // Grup chat verilerinden √ßƒ±karƒ±lan belge, baƒülantƒ± ve fotoƒüraf listeleri
  final RxList<DocumentModel> groupDocuments = <DocumentModel>[].obs;
  final RxList<LinkModel> groupLinks = <LinkModel>[].obs;
  final RxList<String> groupPhotos = <String>[].obs;

  // Mesaj g√∂nderme i√ßin se√ßilen dosyalar ve linkler
  final RxList<File> selectedFiles = <File>[].obs;
  final RxBool isSendingMessage = false.obs;

  RxString pollQuestion = ''.obs;
  RxList<String> pollOptions = <String>[].obs;
  RxMap<String, int> pollVotes = <String, int>{}.obs;
  RxString selectedPollOption = ''.obs;
  TextEditingController pollTitleController = TextEditingController();

  // Survey variables
  RxString surveyTitle = ''.obs;
  RxList<String> surveyChoices = <String>[].obs;
  RxBool isMultipleChoice = false.obs;
  TextEditingController surveyTitleController = TextEditingController();

  // Performance optimization: Cache kullanƒ±cƒ± verileri
  final Map<String, Map<String, dynamic>> _userCache = {};
  bool _isInitialLoad = true;

  // URL algƒ±lama i√ßin regex pattern
  static final RegExp urlRegex = RegExp(
    r'(https?://[^\s]+)|(www\.[^\s]+)|([^\s]+\.[^\s]{2,})',
    caseSensitive: false,
  );

  // Admin kontrol√º - Geni≈ületilmi≈ü yetki kontrol√º
  bool get isCurrentUserAdmin {
    final group = groupData.value;
    
    if (group == null) {
      debugPrint('üîç [GroupChatDetailController] Admin kontrol√º: Group data null');
      return false;
    }
    
    // 1. Grup kurucusu kontrol√º
    final isFounder = group.isFounder;
    debugPrint('üîç [GroupChatDetailController] Admin kontrol√º: isFounder=$isFounder');
    
    // 2. Admin sayƒ±sƒ± kontrol√º (user_count_with_admin > 0 ise admin var)
    final hasAdminUsers = group.userCountWithAdmin > 0;
    debugPrint('üîç [GroupChatDetailController] Admin kontrol√º: hasAdminUsers=$hasAdminUsers');
    
    // 3. Grup √ºyesi kontrol√º
    final isMember = group.isMember;
    debugPrint('üîç [GroupChatDetailController] Admin kontrol√º: isMember=$isMember');
    
    // Admin yetkisi: Grup kurucusu VEYA admin sayƒ±sƒ± > 0 olan grupta √ºye olmak
    final isAdmin = isFounder || (hasAdminUsers && isMember);
    debugPrint('üîç [GroupChatDetailController] Admin kontrol√º: Final result=$isAdmin');
    
    return isAdmin;
  }

  // Link algƒ±lama fonksiyonu
  List<String> extractUrlsFromText(String text) {
    final matches = urlRegex.allMatches(text);
    return matches.map((match) => match.group(0)!).toList();
  }

  // URL'yi normalize et (http:// ekle)
  String normalizeUrl(String url) {
    if (!url.startsWith('http://') && !url.startsWith('https://')) {
      return 'https://$url';
    }
    return url;
  }

  // Mesaj i√ßeriƒüinde link var mƒ± kontrol et
  bool hasLinksInText(String text) {
    return urlRegex.hasMatch(text);
  }

  // Link olmayan text'i √ßƒ±kar
  String extractNonLinkText(String text) {
    return text.replaceAll(urlRegex, '').trim();
  }

  @override
  void onInit() {
    super.onInit();
    debugPrint('üîç Group chat detail controller onInit called');
    
    // Socket servisini initialize et
    _socketService = Get.find<SocketService>();
    _setupSocketListeners();
    
    // PAGINATION: Initialize scroll listener for lazy loading
    _setupPaginationScrollListener();
    
    // Arguments'ƒ± g√ºvenli bir ≈üekilde kontrol et
    final arguments = Get.arguments as Map<String, dynamic>?;
    if (arguments != null && arguments['groupId'] != null) {
      currentGroupId.value = arguments['groupId'].toString();
      debugPrint('‚úÖ Current group ID set to: ${currentGroupId.value}');
      
      // Optimize: Sadece burada y√ºkle, initState'te tekrar √ßaƒüƒ±rma
      _loadGroupDataProgressive();
      
      // Group chat'e girdiƒüinde socket durumunu kontrol et
      onGroupChatEntered();
      
      // ƒ∞lk y√ºkleme sonrasƒ± pin durumlarƒ±nƒ± kontrol et
      Future.delayed(Duration(milliseconds: 1000), () {
        _updatePinStatusFromAPI();
      });
      
      // Cache'i temizle (Android'de g√ºncel olmayan veri sorunu i√ßin)
      GroupServices.clearGroupCache();
    } else {
      debugPrint('‚ùå No group ID provided in arguments');
      // Custom snackbar kullan ve g√ºvenli navigation
      final languageService = Get.find<LanguageService>();
      CustomSnackbar.show(
        title: languageService.tr("common.error"),
        message: languageService.tr("groups.errors.noGroupSelected"),
        type: SnackbarType.error,
        duration: const Duration(seconds: 3),
      );
      
      // G√ºvenli navigation
      Future.delayed(const Duration(seconds: 1), () {
        if (Get.isRegistered<GroupChatDetailController>()) {
          Get.back();
        }
      });
    }
  }

  /// SCROLL: Setup scroll listener for scroll to bottom button
  void _setupPaginationScrollListener() {
    scrollController.addListener(() {
      // SCROLL TO BOTTOM BUTTON: Show/hide based on scroll position
      if (scrollController.hasClients && messages.isNotEmpty) {
        final maxScroll = scrollController.position.maxScrollExtent;
        final currentScroll = scrollController.position.pixels;
        final isNearBottom = (maxScroll - currentScroll) < 200; // Show button if user scrolled up more than 200px
        
        showScrollToBottomButton.value = !isNearBottom && maxScroll > 0;
      }
    });
  }



  /// Progressive loading: √ñnce grup verilerini y√ºkle, sonra mesajlarƒ±
  Future<void> _loadGroupDataProgressive() async {
    try {
      isGroupDataLoading.value = true;
      
      // STEP 1: Quick message loading (√∂nce sadece mesajlarƒ± al)
      await fetchGroupDetailsOptimized();
      
      // STEP 2: API'den gelen pin durumlarƒ±nƒ± kontrol et ve UI'ƒ± g√ºncelle
      _updatePinStatusFromAPI();
      
      // STEP 3: Socket √ºzerinden g√ºncel pin durumlarƒ±nƒ± kontrol et
      await _checkPinStatusFromSocket();
      
      isGroupDataLoading.value = false;
      
      // ƒ∞lk y√ºkleme sonrasƒ± scroll
      if (_isInitialLoad) {
        _isInitialLoad = false;
        WidgetsBinding.instance.addPostFrameCallback((_) {
          scrollToBottomAfterLoad();
        });
      }
      
    } catch (e) {
      debugPrint('‚ùå Progressive loading error: $e');
      isGroupDataLoading.value = false;
      isMessagesLoading.value = false;
    }
  }

  /// OPTIMIZED: Faster group details fetching
  Future<void> fetchGroupDetailsOptimized() async {
    if (currentGroupId.value.isEmpty) {
      debugPrint('‚ùå Cannot fetch group details: No group ID provided');
      return;
    }

    try {
      debugPrint('üöÄ Fast-fetching group details for group ID: ${currentGroupId.value}');
      
      // OPTIMIZE: Try cache first, then API
      GroupDetailModel? group;
      
      try {
        // Try cached version first
        group = await _groupServices.fetchGroupDetailCached(currentGroupId.value)
            .timeout(const Duration(seconds: 10)); // 3'ten 10'a √ßƒ±karƒ±ldƒ±
      } catch (e) {
        debugPrint('‚ö†Ô∏è Cache failed, trying direct API: $e');
        // Fallback to direct API call
        group = await _groupServices.fetchGroupDetail(currentGroupId.value)
            .timeout(const Duration(seconds: 15)); // 5'ten 15'e √ßƒ±karƒ±ldƒ±
      }
      
      groupData.value = group;
      
      // Group chat i√ßin conversation_id'yi g√ºncelle
      if (group.conversationId != null) {
        currentConversationId.value = group.conversationId!;
        debugPrint('üìå [GroupChatDetailController] Updated conversation ID from group data: ${group.conversationId}');
      }
      
      // OPTIMIZE: Process messages in background
      Future.microtask(() {
        convertGroupChatsToMessagesOptimized();
      });
      
      debugPrint('‚úÖ Group details loaded successfully (optimized)');
    } catch (e) {
      debugPrint('‚ùå Error fetching group details: $e');
      
      Get.snackbar(
        _languageService.tr('groupChat.errors.loadFailed'),
        _languageService.tr('groupChat.errors.tryAgain'),
        snackPosition: SnackPosition.BOTTOM,
        duration: Duration(seconds: 3),
        backgroundColor: Colors.orange.shade100,
        colorText: Colors.orange.shade800,
      );
    }
  }

  /// Socket event dinleyicilerini ayarla
  void _setupSocketListeners() {
    // Multiple subscription guard
    if (_isSocketListenerSetup) {
      debugPrint('‚ö†Ô∏è Group chat socket listeners already setup, skipping...');
      return;
    }
    
    // Chat liste controller'ƒ±n group message listener'ƒ±nƒ± durdur (Artƒ±k gerekli deƒüil - s√ºrekli aktif)
    debugPrint('üì¥ ChatController group message listener artƒ±k duraklatƒ±lmƒ±yor - s√ºrekli aktif');
    
    // Group mesaj dinleyicisi - user:{user_id} kanalƒ±ndan
    _groupMessageSubscription = _socketService.onGroupMessage.listen((data) {
      _onNewGroupMessage(data);
    });

    // Pin message dinleyicisi - pin/unpin event'leri i√ßin
    _pinMessageSubscription = _socketService.onPinMessage.listen((data) {
      _onPinMessageUpdate(data);
    });

    
    _isSocketListenerSetup = true;
    debugPrint('‚úÖ GroupChatDetailController socket listeners setup completed');
  }

  /// Group message listener'ƒ±nƒ± duraklat
  void pauseGroupMessageListener() {
    try {
      debugPrint('‚è∏Ô∏è PAUSE REQUEST: GroupChatDetailController group message listener pause requested');
      debugPrint('‚è∏Ô∏è Current state: isPaused=${_groupMessageSubscription.isPaused}');
      
      if (!_groupMessageSubscription.isPaused) {
        _groupMessageSubscription.pause();
        debugPrint('‚è∏Ô∏è SUCCESS: GroupChatDetailController group message listener paused');
      } else {
        debugPrint('‚è∏Ô∏è ALREADY PAUSED: GroupChatDetailController group message listener was already paused');
      }
      
      // Verification
      debugPrint('‚è∏Ô∏è VERIFICATION: isPaused=${_groupMessageSubscription.isPaused}');
      
    } catch (e) {
      debugPrint('‚ùå PAUSE ERROR: Group message listener pause failed: $e');
    }
  }

  /// Group message listener'ƒ±nƒ± devam ettir
  void resumeGroupMessageListener() {
    try {
      debugPrint('‚ñ∂Ô∏è RESUME REQUEST: GroupChatDetailController group message listener resume requested');
      debugPrint('‚ñ∂Ô∏è Current state: isPaused=${_groupMessageSubscription.isPaused}');
      
      if (_groupMessageSubscription.isPaused) {
        _groupMessageSubscription.resume();
        debugPrint('‚ñ∂Ô∏è SUCCESS: GroupChatDetailController group message listener resumed');
      } else {
        debugPrint('‚ñ∂Ô∏è ALREADY ACTIVE: GroupChatDetailController group message listener was already active');
      }
      
      // Verification  
      debugPrint('‚ñ∂Ô∏è VERIFICATION: isPaused=${_groupMessageSubscription.isPaused}');
      
    } catch (e) {
      debugPrint('‚ùå RESUME ERROR: Group message listener resume failed: $e');
    }
  }

  /// Yeni grup mesajƒ± geldiƒüinde i≈üle - OPTIMIZE
  void _onNewGroupMessage(dynamic data) {
    try {
      
      if (data is Map<String, dynamic>) {
        // Socket'ten gelen data yapƒ±sƒ±: {message: {group_id: 2, ...}}
        final messageData = data['message'] as Map<String, dynamic>?;
        final incomingGroupId = messageData?['group_id']?.toString();
        
        
        // Sadece bu grup i√ßin gelen mesajlarƒ± i≈üle
        if (incomingGroupId != null && incomingGroupId == currentGroupId.value) {
          
          // Pin durumu kontrol√º - eƒüer mesaj zaten varsa ve pin durumu deƒüi≈ütiyse
          final messageId = messageData?['id']?.toString();
          final isPinned = messageData?['is_pinned'] ?? false;
          
          
          // Pin durumu deƒüi≈üikliƒüi varsa √∂zel i≈ülem yap
          if (messageId != null && messageData?.containsKey('is_pinned') == true) {
            debugPrint('üîç [GroupChatDetailController] Pin durumu deƒüi≈üikliƒüi tespit edildi, √∂zel i≈ülem yapƒ±lƒ±yor');
            
            final existingMessageIndex = messages.indexWhere((msg) => msg.id == messageId);
            debugPrint('üîç [GroupChatDetailController] Existing message index: $existingMessageIndex');
            
            if (existingMessageIndex != -1) {
              // Mesaj zaten var - pin durumu g√ºncellemesi
              final existingMessage = messages[existingMessageIndex];
              debugPrint('üîç [GroupChatDetailController] Mevcut mesaj bulundu: ID=${existingMessage.id}, Mevcut Pin=${existingMessage.isPinned}, Yeni Pin=$isPinned');
              
              if (existingMessage.isPinned != isPinned) {
                debugPrint('üìå Pin durumu deƒüi≈üikliƒüi tespit edildi: Message ID=$messageId, isPinned=$isPinned');
                
                // Mesajƒ±n pin durumunu g√ºncelle
                messages[existingMessageIndex] = existingMessage.copyWith(isPinned: isPinned);
                
                // PinnedMessagesWidget'ƒ± g√ºncelle
                update();
                
                
                // Pin durumu deƒüi≈üikliƒüi i√ßin √∂zel bildirim g√∂nder
                _notifyPinStatusChange(messageId, isPinned);
                
                // Pin/Unpin i≈ülemi i√ßin √∂zel log
                if (isPinned) {
                  debugPrint('üìå [GroupChatDetailController] Message $messageId PINNED - PinnedMessagesWidget g√ºncellenmeli');
                } else {
                  debugPrint('üìå [GroupChatDetailController] Message $messageId UNPINNED - PinnedMessagesWidget\'dan kaldƒ±rƒ±lmalƒ±');
                }
                
                return; // Yeni mesaj ekleme i≈ülemini yapma
              } else {
                debugPrint('üîç [GroupChatDetailController] Pin durumu deƒüi≈ümedi, normal mesaj i≈ülemi devam ediyor');
              }
            } else {
              debugPrint('üîç [GroupChatDetailController] Mesaj hen√ºz listede yok, yeni mesaj olarak ekleniyor');
            }
          } else {
            debugPrint('üîç [GroupChatDetailController] Pin durumu kontrol√º yapƒ±lmadƒ± - messageId: $messageId, contains is_pinned: ${messageData?.containsKey('is_pinned')}');
          }
          
          // OPTIMIZE: T√ºm grup detayƒ±nƒ± tekrar √ßekme, sadece yeni mesajƒ± ekle
          _addNewMessageFromSocket(data);
          
          debugPrint('‚úÖ Yeni grup mesajƒ± i≈ülendi');
        } else {
          debugPrint('üì° Gelen grup mesajƒ± bu gruba ait deƒüil. Gelen: $incomingGroupId, Mevcut: ${currentGroupId.value}');
          debugPrint('üì° Data yapƒ±sƒ±: $data');
        }
      }
    } catch (e) {
      debugPrint('‚ùå _onNewGroupMessage error: $e');
    }
  }

  /// Pin durumu deƒüi≈üikliƒüi i√ßin √∂zel bildirim g√∂nder
  void _notifyPinStatusChange(String messageId, bool isPinned) {
    try {
      debugPrint('üìå [GroupChatDetailController] Pin durumu deƒüi≈üikliƒüi bildirimi g√∂nderiliyor');
      debugPrint('üìå Message ID: $messageId, Is Pinned: $isPinned');
      
      // PinnedMessagesWidget'ƒ±n anlƒ±k g√ºncellenmesi i√ßin √∂zel event g√∂nder
      final pinUpdateData = {
        'message_id': messageId,
        'is_pinned': isPinned,
        'group_id': currentGroupId.value,
        'timestamp': DateTime.now().millisecondsSinceEpoch,
      };
      
      // Pin event'ini tetikle - bu zaten _onPinMessageUpdate metodunda i≈ülenecek
      _onPinMessageUpdate(pinUpdateData);
      
      debugPrint('üìå [GroupChatDetailController] Pin durumu deƒüi≈üikliƒüi bildirimi g√∂nderildi');
    } catch (e) {
      debugPrint('‚ùå [GroupChatDetailController] Pin durumu bildirimi hatasƒ±: $e');
    }
  }

  /// Test i√ßin manuel pin durumu g√ºncelleme
  void updateMessagePinStatus(String messageId, bool isPinned) {
    try {
      debugPrint('üìå [GroupChatDetailController] Manual pin status update requested');
      debugPrint('üìå Message ID: $messageId, Is Pinned: $isPinned');
      
      final messageIndex = messages.indexWhere((msg) => msg.id == messageId);
      if (messageIndex != -1) {
        final existingMessage = messages[messageIndex];
        debugPrint('üìå [GroupChatDetailController] Found message at index $messageIndex');
        debugPrint('üìå [GroupChatDetailController] Current pin status: ${existingMessage.isPinned}');
        
        if (existingMessage.isPinned != isPinned) {
          final updatedMessage = existingMessage.copyWith(isPinned: isPinned);
          messages[messageIndex] = updatedMessage;
          debugPrint('üìå [GroupChatDetailController] Message pin status updated manually');
          
          // PinnedMessagesWidget'ƒ± g√ºncelle
          update();
          
          debugPrint('üìå [GroupChatDetailController] Manual pin update completed');
          debugPrint('üìå [GroupChatDetailController] Pinned messages count: ${messages.where((m) => m.isPinned).length}');
        } else {
          debugPrint('üìå [GroupChatDetailController] Pin status already matches, no update needed');
        }
      } else {
        debugPrint('‚ö†Ô∏è [GroupChatDetailController] Message with ID $messageId not found for manual update');
      }
    } catch (e) {
      debugPrint('‚ùå [GroupChatDetailController] Manual pin status update error: $e');
    }
  }

  /// Test i√ßin socket event'ini manuel olarak i≈üle
  void processSocketEvent(dynamic data) {
    try {
      debugPrint('üìå [GroupChatDetailController] Manual socket event processing requested');
      debugPrint('üìå Event data: $data');
      
      // Socket event'ini manuel olarak i≈üle
      _onNewGroupMessage(data);
      
      debugPrint('üìå [GroupChatDetailController] Manual socket event processing completed');
    } catch (e) {
      debugPrint('‚ùå [GroupChatDetailController] Manual socket event processing error: $e');
    }
  }

  /// PinnedMessagesWidget'ƒ± zorla yenile
  void forceRefreshPinnedWidget() {
    try {
      debugPrint('üìå [GroupChatDetailController] Force refresh PinnedMessagesWidget requested');
      
      // Widget'ƒ± zorla yenile
      update();
      
      debugPrint('üìå [GroupChatDetailController] PinnedMessagesWidget force refresh completed');
      debugPrint('üìå [GroupChatDetailController] Current pinned messages count: ${messages.where((m) => m.isPinned).length}');
    } catch (e) {
      debugPrint('‚ùå [GroupChatDetailController] Force refresh error: $e');
    }
  }

  /// Debug: Pinlenmi≈ü mesajlarƒ± listele
  void debugPinnedMessages() {
    try {
      debugPrint('üîç [GroupChatDetailController] Debug: Pinned messages check');
      debugPrint('üîç [GroupChatDetailController] Total messages: ${messages.length}');
      
      final pinnedMessages = messages.where((m) => m.isPinned).toList();
      debugPrint('üîç [GroupChatDetailController] Pinned messages count: ${pinnedMessages.length}');
      
      for (int i = 0; i < pinnedMessages.length; i++) {
        final msg = pinnedMessages[i];
        debugPrint('üîç [GroupChatDetailController] Pinned message $i: ID=${msg.id}, Content="${msg.content}", Username=${msg.username}');
      }
    } catch (e) {
      debugPrint('‚ùå [GroupChatDetailController] Debug error: $e');
    }
  }

  /// Socket'ten gelen yeni mesajƒ± direkt ekle (API √ßaƒürƒ±sƒ± yapma)
  void _addNewMessageFromSocket(Map<String, dynamic> data) {
    try {
      debugPrint('üì° [GroupChatDetailController] Yeni grup mesajƒ± payload alƒ±ndƒ±');
      debugPrint('üì° [GroupChatDetailController] Current Group ID: ${currentGroupId.value}');
      debugPrint('üì° [GroupChatDetailController] Processing: $data');
      
      // Socket'ten gelen data yapƒ±sƒ±: {message: {user_id: 6, group_id: 2, message: "text", ...}}
      final messageData = data['message'] as Map<String, dynamic>?;
      if (messageData == null) {
        debugPrint('‚ùå [GroupChatDetailController] Message data is null');
        return;
      }
      
      // Yeni mesajƒ± parse et ve listeye ekle
      final currentUserId = Get.find<ProfileController>().userId.value;
      
      // DUPLICATE CHECK: Aynƒ± ID'li mesaj var mƒ± kontrol et
      final messageId = messageData['id']?.toString() ?? DateTime.now().millisecondsSinceEpoch.toString();
      final isDuplicate = messages.any((existingMessage) => existingMessage.id == messageId);
      if (isDuplicate) {
        debugPrint('üö´ [GroupChatDetailController] DUPLICATE MESSAGE BLOCKED: ID $messageId already exists');
        return;
      }
      
      // User data'yƒ± al
      final userData = messageData['user'] as Map<String, dynamic>?;
      
      // Message type'ƒ± belirle
      GroupMessageType messageType = GroupMessageType.text;
      String content = messageData['message'] ?? '';
      List<String>? pollOptions;
      bool? isMultipleChoice;
      int? surveyId;
      List<String>? links;
      List<String>? media;
      
      // Survey mesajlarƒ± i√ßin √∂zel i≈ülem
      if (messageData['type'] == 'survey' && messageData['survey'] != null) {
        messageType = GroupMessageType.survey;
        final surveyData = messageData['survey'] as Map<String, dynamic>;
        content = surveyData['title'] ?? '';
        isMultipleChoice = surveyData['multiple_choice'] ?? false;
        surveyId = surveyData['id'];
        
        // Survey se√ßeneklerini al
        if (surveyData['choices'] != null) {
          final choices = surveyData['choices'] as List<dynamic>;
          pollOptions = choices.map((choice) => (choice['title'] ?? '').toString()).toList();
        }
      } else if (messageData['type'] == 'poll') {
        messageType = GroupMessageType.poll;
        // Poll se√ßeneklerini al
        if (messageData['poll_options'] != null) {
          pollOptions = List<String>.from(messageData['poll_options']);
        }
      }
      
      // Media ve link bilgilerini al
      if (messageData['media'] != null) {
        final mediaList = messageData['media'] as List<dynamic>;
        media = mediaList.map((m) => m['full_path'] ?? m['path'] ?? '').cast<String>().toList();
      }
      
      if (messageData['group_chat_link'] != null) {
        final linkList = messageData['group_chat_link'] as List<dynamic>;
        links = linkList.map((l) => l['link'] ?? '').cast<String>().toList();
      }
      

      
      final newMessage = GroupMessageModel(
        id: messageId,
        senderId: messageData['user_id']?.toString() ?? '',
        receiverId: currentGroupId.value,
        name: userData?['name'] ?? '',
        surname: userData?['surname'] ?? '',
        username: userData?['username'] ?? '',
        profileImage: userData?['avatar_url'] ?? '',
        content: content,
        messageType: messageType,
        timestamp: DateTime.parse(messageData['created_at'] ?? DateTime.now().toIso8601String()),
        isSentByMe: messageData['user_id']?.toString() == currentUserId,
        pollOptions: pollOptions,
        isMultipleChoice: isMultipleChoice,
        surveyId: surveyId,
        links: links,
        media: media,
      );
      
      messages.add(newMessage);
      debugPrint('‚úÖ [GroupChatDetailController] Yeni grup mesajƒ± eklendi: ID ${newMessage.id}, Content: "${newMessage.content}"');
      debugPrint('‚úÖ [GroupChatDetailController] Toplam grup mesaj sayƒ±sƒ±: ${messages.length}');
      
      // Yeni mesaj eklendiƒüinde en alta git
      WidgetsBinding.instance.addPostFrameCallback((_) {
        scrollToBottomForNewMessage();
      });
      
    } catch (e) {
      debugPrint('‚ùå [GroupChatDetailController] _addNewMessageFromSocket error: $e');
      // Fallback: T√ºm mesajlarƒ± yeniden y√ºkle
      refreshMessagesOnly();
    }
  }



  /// Group chat socket durumunu kontrol et
  void checkGroupChatSocketConnection() {
    
    // Socket service'den detaylƒ± durum raporu al
    _socketService.checkSocketStatus();
    
  }

  /// Group chat'e girdiƒüinde socket durumunu kontrol et
  void onGroupChatEntered() {
    debugPrint('üö™ Group chat\'e girildi, socket durumu kontrol ediliyor...');
    checkGroupChatSocketConnection();
    
    // Group chat'e girdiƒüinde gruba join ol
    if (_socketService.isConnected.value) {
      
      final joinData = {
        'group_id': currentGroupId.value,
      };
      
      
      _socketService.sendMessage('group:join', joinData);
      
      debugPrint('‚úÖ group:join event\'i ba≈üarƒ±yla g√∂nderildi!');
    } else {
      debugPrint('‚ùå Socket baƒülantƒ±sƒ± yok! group:join g√∂nderilemedi.');
      debugPrint('üîç Socket durumu: ${_socketService.isConnected.value}');
    }
  }



  /// OPTIMIZE: Background message conversion with pagination support
  Future<void> convertGroupChatsToMessagesOptimized() async {
    if (groupData.value?.groupChats == null) return;
    
    try {
      final groupChats = groupData.value!.groupChats;
      final currentUserId = Get.find<ProfileController>().userId.value;
      
      // DEBUG: Group mesajlarƒ±nƒ±n sayƒ±sƒ±nƒ± yazdƒ±r
      debugPrint('üìä Group chats count: ${groupChats.length}');
      
      // PAGINATION: Process all messages without limit
      final messagesToProcess = groupChats;
      
      // Performance: Batch processing
      final processedMessages = <GroupMessageModel>[];
      
      // Cache kullanƒ±cƒ± verilerini tek seferde
      for (final chat in messagesToProcess) {
        final userId = chat.userId.toString();
        if (!_userCache.containsKey(userId)) {
          _userCache[userId] = chat.user;
        }
      }
      
      // OPTIMIZE: Process in smaller batches to prevent UI freeze
      const batchSize = 10;
      for (int i = 0; i < messagesToProcess.length; i += batchSize) {
        final batch = messagesToProcess.skip(i).take(batchSize);
        
        for (final chat in batch) {
          try {
            final userId = chat.userId.toString();
            final user = _userCache[userId]!;
            final isSentByMe = userId == currentUserId;
            
            // FIXED: Safe message type determination
            final messageData = _determineMessageType(chat);
            
            // Media dosyalarƒ±nƒ± al
            List<String>? mediaUrls;
            if (chat.media.isNotEmpty) {
              mediaUrls = chat.media.map((media) => media.fullPath).toList();
            }
            

            
            final message = GroupMessageModel(
                  id: chat.id.toString(),
                  senderId: userId,
                  receiverId: chat.groupId.toString(),
                  name: user['name'] ?? '',
                  surname: user['surname'] ?? '',
                  username: user['username'] ?? user['name'] ?? '',
                  profileImage: user['avatar_url'] ?? '',
                  content: messageData['content'],
                  messageType: messageData['type'],
                  timestamp: DateTime.parse(chat.createdAt),
                  isSentByMe: isSentByMe,
                  pollOptions: messageData['pollOptions'],
                  additionalText: messageData['additionalText'],
                  links: messageData['links'],
                  media: mediaUrls,
                  isMultipleChoice: messageData['isMultipleChoice'],
                  surveyId: messageData['surveyId'],
                  choiceIds: messageData['choiceIds'],
                  surveyData: messageData['surveyData'],
                  isPinned: chat.isPinned, // Pin durumunu ekle
                );
            
            processedMessages.add(message);
          } catch (e) {
            debugPrint('‚ö†Ô∏è Error processing message ${chat.id}: $e');
            // Skip this message and continue
          }
        }
        
        // Allow UI to update between batches
        if (i + batchSize < messagesToProcess.length) {
          await Future.delayed(Duration(milliseconds: 1));
        }
      }
      
      // FIXED: API'den gelen mesajlar zaten doƒüru sƒ±ralƒ± (en yeni en altta)
      // API sƒ±rasƒ±nƒ± koru, ekstra sƒ±ralama yapma
      // processedMessages.sort((a, b) => a.timestamp.compareTo(b.timestamp));
      
      // PAGINATION: Update state based on first load or not
      if (isFirstLoad.value) {
        messages.assignAll(processedMessages);
        
        // Since we're loading all messages, no more messages to load
        hasMoreMessages.value = false;
        
        isFirstLoad.value = false;
        debugPrint('‚úÖ Initial ${processedMessages.length} group messages loaded (proper chronological order)');
        debugPrint('üìä Mesaj sayƒ±sƒ± kontrol√º: ${messages.length} mesaj y√ºklendi');
        
        // Pin durumu debug log'larƒ±
        final pinnedCount = messages.where((msg) => msg.isPinned).length;
        debugPrint('üìå Pin durumu kontrol√º: $pinnedCount pinlenmi≈ü mesaj bulundu');
        for (int i = 0; i < messages.length; i++) {
          final msg = messages[i];
          if (msg.isPinned) {
            debugPrint('üìå Pinlenmi≈ü mesaj $i: ID=${msg.id}, Content="${msg.content}"');
          }
        }
        
        // Pinlenmi≈ü mesajlar varsa UI'ƒ± g√ºncelle
        if (pinnedCount > 0) {
          update();
          debugPrint('üìå UI g√ºncellendi - pinlenmi≈ü mesajlar g√∂steriliyor');
        }
      } else {
        messages.assignAll(processedMessages);
        debugPrint('üìä Mesaj sayƒ±sƒ± g√ºncellendi: ${messages.length} mesaj');
        
        // Pin durumu debug log'larƒ±
        final pinnedCount = messages.where((msg) => msg.isPinned).length;
        debugPrint('üìå Pin durumu kontrol√º: $pinnedCount pinlenmi≈ü mesaj bulundu');
      }
      
      // Extract media in background
      Future.microtask(() {
        extractGroupChatMedia();
      });
      
      debugPrint('‚úÖ Processed ${processedMessages.length} messages successfully');
      
    } catch (e) {
      debugPrint('‚ùå Error in convertGroupChatsToMessagesOptimized: $e');
    }
  }

  /// Helper function for message type determination - FIXED
  Map<String, dynamic> _determineMessageType(dynamic chat) {
    GroupMessageType messageType = GroupMessageType.text;
    String content = chat.message ?? '';
    List<String>? links;
    List<String>? pollOptions;
                  String? additionalText;
              bool? isMultipleChoice;
              int? surveyId;
              List<int>? choiceIds;
              Map<String, dynamic>? surveyData;
    

    
                  try {
                if (chat.messageType == 'poll') {
                  messageType = GroupMessageType.poll;
                  content = chat.message ?? '';
                  pollOptions = ['Se√ßenek 1', 'Se√ßenek 2']; 
                } else if (chat.messageType == 'survey' || chat.surveyId != null || chat.survey != null) {
                  messageType = GroupMessageType.survey;
                  
                  debugPrint('üîç Survey mesajƒ± tespit edildi');
                  debugPrint('üîç chat.survey: ${chat.survey}');
                  debugPrint('üîç chat.message: ${chat.message}');
                  debugPrint('üîç chat.surveyId: ${chat.surveyId}');
                  
                  // Survey verisi survey objesi i√ßinde geliyor
                  if (chat.survey != null) {
                    content = chat.survey['title'] ?? '';
                    isMultipleChoice = chat.survey['multiple_choice'] ?? false;
                    surveyId = chat.survey['id'];
                    surveyData = chat.survey; // T√ºm survey verisini sakla
                    
                    debugPrint('üîç Survey title: $content');
                    debugPrint('üîç Survey multiple_choice: $isMultipleChoice');
                    debugPrint('üîç Survey ID: $surveyId');
                    
                    // Survey se√ßeneklerini al
                    if (chat.survey['choices'] != null) {
                      final choices = chat.survey['choices'] as List<dynamic>;
                      pollOptions = choices.map((choice) => choice['title'] ?? '').cast<String>().toList();
                      choiceIds = choices.map((choice) => choice['id'] ?? 0).cast<int>().toList();
                      debugPrint('üîç Survey choices: $pollOptions');
                      debugPrint('üîç Survey choice IDs: $choiceIds');
                    }
                  } else {
                    // Fallback
                    content = chat.message ?? '';
                    isMultipleChoice = false;
                    surveyId = chat.surveyId;
                    debugPrint('üîç Fallback - content: $content');
                  }
      } else if (chat.media != null && chat.media.isNotEmpty) {
        final media = chat.media.first;
        if (media.type != null && media.type.toString().startsWith('image/')) {
          // Eƒüer hem text hem image varsa, textWithLinks tipini kullan (universal widget i√ßin)
          if (chat.message != null && chat.message.toString().isNotEmpty) {
            messageType = GroupMessageType.textWithLinks;
            content = chat.message.toString();
          } else {
            messageType = GroupMessageType.image;
            content = media.fullPath ?? '';
          }
        } else {
          messageType = GroupMessageType.document;
          content = media.fullPath ?? '';
        }
      }
      
      // Link kontrol√º - media kontrol√ºnden sonra yapƒ±lmalƒ±
      if (chat.groupChatLink != null && chat.groupChatLink.isNotEmpty) {
        // FIXED: Safe type casting for links
        final chatLinks = <String>[];
        
        for (var link in chat.groupChatLink) {
          if (link?.link != null) {
            final linkStr = link.link.toString();
            if (linkStr.isNotEmpty) {
              chatLinks.add(linkStr);
            }
          }
        }
        
        if (chat.message != null && chat.message.toString().isNotEmpty) {
          messageType = GroupMessageType.textWithLinks;
          content = chat.message.toString();
          links = chatLinks.isNotEmpty ? chatLinks : null;
        } else if (chatLinks.isNotEmpty) {
          // Eƒüer sadece link varsa ve media da varsa, textWithLinks kullan
          if (chat.media != null && chat.media.isNotEmpty) {
            messageType = GroupMessageType.textWithLinks;
            content = ''; // Bo≈ü text
            links = chatLinks.isNotEmpty ? chatLinks : null;
          } else {
            messageType = GroupMessageType.link;
            content = chatLinks.first;
          }
        }
      }
    } catch (e) {
      debugPrint('‚ùå Error determining message type: $e');
      // Fallback to text message
      messageType = GroupMessageType.text;
      content = chat.message?.toString() ?? '';
    }
    
                  return {
                'type': messageType,
                'content': content,
                'links': links,
                'pollOptions': pollOptions,
                'additionalText': additionalText,
                'isMultipleChoice': isMultipleChoice,
                'surveyId': surveyId,
                'choiceIds': choiceIds,
                'surveyData': surveyData,
              };
  }

  /// FIXED: Proper scroll to bottom with timing
  void scrollToBottomAfterLoad() {
    debugPrint('üìú Group Chat - scrollToBottomAfterLoad called, messages: ${messages.length}');
    
    // Allow UI to render first
    WidgetsBinding.instance.addPostFrameCallback((_) {
      // Multiple delayed attempts for better reliability
      Future.delayed(Duration(milliseconds: 100), () {
        if (scrollController.hasClients && messages.isNotEmpty) {
          scrollToBottom(animated: false);
        }
      });
      
      // Second attempt with longer delay
      Future.delayed(Duration(milliseconds: 300), () {
        if (scrollController.hasClients && messages.isNotEmpty) {
          scrollToBottom(animated: false);
        }
      });
      
      // Final attempt
      Future.delayed(Duration(milliseconds: 600), () {
        if (scrollController.hasClients && messages.isNotEmpty) {
          scrollToBottom(animated: false);
        }
      });
    });
  }

  /// FIXED: Scroll to bottom for new messages
  void scrollToBottomForNewMessage() {
    final currentMessageCount = messages.length;
    debugPrint('üìú Group Chat - scrollToBottomForNewMessage called, messages: $currentMessageCount, last: $_lastMessageCount');
    
    // Only scroll if message count actually increased (new message added)
    if (currentMessageCount <= _lastMessageCount) {
      debugPrint('üìú Group Chat - No new messages, skipping auto-scroll');
      return;
    }
    
    _lastMessageCount = currentMessageCount;
    
    // Check if user is already at bottom (within 100px) before scrolling
    if (scrollController.hasClients) {
      final position = scrollController.position;
      final isNearBottom = position.maxScrollExtent - position.pixels < 100;
      
      if (!isNearBottom) {
        debugPrint('üìú Group Chat - User scrolled away from bottom, not auto-scrolling');
        return;
      }
    }
    
    // Immediate scroll for new messages
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (scrollController.hasClients && messages.isNotEmpty) {
        debugPrint('üìú Group Chat - Auto-scrolling to bottom for new message');
        scrollToBottom(animated: true);
      }
    });
  }

  /// Test function for manual scroll
  void testScrollToBottom() {
    debugPrint('üß™ === SCROLL TEST ===');
    debugPrint('üß™ Messages count: ${messages.length}');
    debugPrint('üß™ ScrollController hasClients: ${scrollController.hasClients}');
    if (scrollController.hasClients) {
      debugPrint('üß™ Current position: ${scrollController.position.pixels}');
      debugPrint('üß™ Max extent: ${scrollController.position.maxScrollExtent}');
      debugPrint('üß™ Has content dimensions: ${scrollController.position.hasContentDimensions}');
    }
    debugPrint('üß™ Attempting to scroll...');
    scrollToBottom(animated: true);
    debugPrint('üß™ ==================');
  }

  /// Socket ve listener durumunu kontrol et
  void checkSocketConnection() {
    debugPrint('üîç === GRUP CHAT SOCKET DURUM RAPORU ===');
    debugPrint('üîç Current Group ID: ${currentGroupId.value}');
    debugPrint('üîç Socket Service baƒülƒ±: ${_socketService.isConnected.value}');
    
    // Socket service'den durum kontrol√º yap
    _socketService.checkSocketStatus();
    
    debugPrint('üîç Grup mesaj subscription aktif: ${!_groupMessageSubscription.isPaused}');
    debugPrint('üîç ================================');
  }

  void extractGroupChatMedia() {
    if (groupData.value?.groupChats == null) return;
    
    final groupChats = groupData.value!.groupChats;
    
    // Listeleri temizle
    groupDocuments.clear();
    groupLinks.clear();
    groupPhotos.clear();
    
    for (final chat in groupChats) {
      // Belgeler ve fotoƒüraflar
      for (final media in chat.media) {
        if (media.type.startsWith('image/')) {
          // Fotoƒüraf
          if (!groupPhotos.contains(media.fullPath)) {
            groupPhotos.add(media.fullPath);
          }
        } else {
          // Belge
          final document = DocumentModel(
            id: media.id.toString(),
            name: media.title,
            sizeMb: double.tryParse(media.fileSize) ?? 0.0,
            humanCreatedAt: media.humanCreatedAt,
            createdAt: DateTime.parse(chat.createdAt),
            url: media.fullPath,
          );
          
          // Aynƒ± belgeyi tekrar eklemeyi √∂nle
          if (!groupDocuments.any((doc) => doc.id == document.id)) {
            groupDocuments.add(document);
          }
        }
      }
      
      // Baƒülantƒ±lar
      for (final link in chat.groupChatLink) {
        final linkModel = LinkModel(
          url: link.link,
          title: link.linkTitle,
        );
        
        // Aynƒ± baƒülantƒ±yƒ± tekrar eklemeyi √∂nle
        if (!groupLinks.any((l) => l.url == linkModel.url)) {
          groupLinks.add(linkModel);
        }
      }
    }
    
    // Belgeleri tarihe g√∂re sƒ±rala (en yeni √∂nce)
    groupDocuments.sort((a, b) => b.createdAt.compareTo(a.createdAt));
    
    // Linkleri tarihe g√∂re sƒ±rala (en yeni √∂nce)
    // Link'lerin tarih bilgisi yok, mesaj sƒ±rasƒ±na g√∂re sƒ±rala
    // Bu durumda mesaj sƒ±rasƒ±na g√∂re sƒ±rala (en son eklenen en √ºstte)
    
    // Fotoƒüraflarƒ± tarihe g√∂re sƒ±rala (en yeni √∂nce)
    // Fotoƒüraflar mesaj sƒ±rasƒ±na g√∂re zaten sƒ±ralƒ± geliyor
    
    debugPrint('üìÅ Extracted ${groupDocuments.length} documents from group chats (sorted by date)');
    debugPrint('üîó Extracted ${groupLinks.length} links from group chats');
    debugPrint('üì∏ Extracted ${groupPhotos.length} photos from group chats');
  }

  Future<void> fetchGroupMessages() async {
    try {
      debugPrint('Fetching messages for group: ${currentGroupId.value}');
      
      // Grup verileri zaten y√ºklendi, sadece mesajlarƒ± d√∂n√º≈üt√ºr
      if (groupData.value != null) {
        convertGroupChatsToMessagesOptimized();
      }
      
    } catch (e) {
      debugPrint('Error fetching messages: $e');
      Get.snackbar(
        _languageService.tr('groupChat.errors.loadFailed'),
        _languageService.tr('groupChat.errors.messageSendFailed'),
        snackPosition: SnackPosition.BOTTOM
      );
    }
  }

  void openPollBottomSheet() {
    pollQuestion.value = '';
    pollOptions.assignAll(['', '']);
    Get.bottomSheet(
      Container(
        padding: const EdgeInsets.all(16),
        decoration: const BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
        ),
        child: SingleChildScrollView(
          keyboardDismissBehavior: ScrollViewKeyboardDismissBehavior.onDrag,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const SizedBox(height: 20),
              TextField(
                style: TextStyle(fontSize: 12),
                controller: pollTitleController,
                decoration: InputDecoration(
                  hintText: _languageService.tr("chat.poll.title"),
                  filled: true,
                  fillColor: const Color(0xfff5f5f5),
                  hintStyle:
                      const TextStyle(color: Color(0xFF9CA3AF), fontSize: 12),
                  contentPadding:
                      const EdgeInsets.symmetric(horizontal: 12, vertical: 14),
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(15),
                    borderSide: BorderSide.none,
                  ),
                ),
                onChanged: (val) => pollQuestion.value = val,
              ),
              const SizedBox(height: 30),
              Obx(() => Column(
                    children: List.generate(pollOptions.length, (index) {
                      return Padding(
                        padding: const EdgeInsets.only(bottom: 8.0),
                        child: Row(
                          children: [
                            Expanded(
                              child: TextField(
                                style: TextStyle(fontSize: 12),
                                decoration: InputDecoration(
                                  hintText: _languageService.tr("chat.poll.addOption"),
                                  filled: true,
                                  fillColor: const Color(0xfff5f5f5),
                                  hintStyle: const TextStyle(
                                      color: Color(0xFF9CA3AF), fontSize: 12),
                                  contentPadding: const EdgeInsets.symmetric(
                                      horizontal: 12, vertical: 14),
                                  border: OutlineInputBorder(
                                    borderRadius: BorderRadius.circular(15),
                                    borderSide: BorderSide.none,
                                  ),
                                ),
                                onChanged: (val) => pollOptions[index] = val,
                              ),
                            ),
                            const SizedBox(width: 8),
                            if (pollOptions.length > 2)
                              IconButton(
                                icon: const Icon(Icons.remove_circle),
                                onPressed: () => pollOptions.removeAt(index),
                              ),
                          ],
                        ),
                      );
                    }),
                  )),
              TextButton.icon(
                onPressed: () => pollOptions.add(''),
                icon: const Icon(
                  Icons.add,
                  color: Color(0xffED7474),
                  size: 15,
                ),
                label: Text(
                  _languageService.tr("chat.poll.addOption"),
                  style: TextStyle(color: Color(0xffED7474), fontSize: 12),
                ),
              ),
              const SizedBox(height: 30),

              /**
               *  backgroundColor: const Color(0xffFFF6F6),
                    foregroundColor: const Color(0xffED7474),
               */
              CustomButton(
                  text: _languageService.tr("chat.poll.send"),
                  height: 45,
                  borderRadius: 15,
                  onPressed: () {
                    final filledOptions =
                        pollOptions.where((e) => e.trim().isNotEmpty).toList();
                    if (pollTitleController.text.trim().isNotEmpty &&
                        filledOptions.length >= 2) {
                      sendPoll(pollTitleController.text, filledOptions);
                      Get.back();
                    }
                  },
                  isLoading: isSendingMessage,
                  backgroundColor: Color(0xffFFF6F6),
                  textColor: Color(0xffED7474)),
              const SizedBox(height: 20),
            ],
          ),
        ),
      ),
      isScrollControlled: true,
    );
  }

  void votePoll(String option) {
    if (!pollVotes.containsKey(option)) {
      pollVotes[option] = 1;
    } else {
      pollVotes[option] = pollVotes[option]! + 1;
    }
    selectedPollOption.value = option;
  }

  void sendPoll(String question, List<String> options) async {
    if (isSendingMessage.value) return;
    
    isSendingMessage.value = true;
    
    try {
      // Poll mesajƒ±nƒ± API'ye g√∂nder
      final success = await _groupServices.sendGroupMessage(
        groupId: currentGroupId.value,
        message: question,
        pollOptions: options,
      );
      
      if (success) {
        // Ba≈üarƒ±lƒ± ise mesajlarƒ± yeniden y√ºkle
        await refreshMessagesOnly();
        
        // Poll g√∂nderildikten sonra en alta git
        WidgetsBinding.instance.addPostFrameCallback((_) {
          scrollToBottom(animated: true);
        });
      } else {
        Get.snackbar(
          'Hata',
          'Anket g√∂nderilemedi',
          snackPosition: SnackPosition.BOTTOM,
        );
      }
    } catch (e) {
      debugPrint('Anket g√∂nderme hatasƒ±: $e');
      Get.snackbar(
        'Hata',
        'Anket g√∂nderilemedi',
        snackPosition: SnackPosition.BOTTOM,
      );
    } finally {
      isSendingMessage.value = false;
    }
  }

  // Survey functions
  void openSurveyBottomSheet() {
    surveyTitle.value = '';
    surveyChoices.assignAll(['', '']);
    isMultipleChoice.value = false;
    surveyTitleController.clear();
    
    Get.bottomSheet(
      Container(
        padding: const EdgeInsets.all(16),
        decoration: const BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
        ),
        child: SingleChildScrollView(
          keyboardDismissBehavior: ScrollViewKeyboardDismissBehavior.onDrag,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const SizedBox(height: 20),
              TextField(
                style: TextStyle(fontSize: 12),
                controller: surveyTitleController,
                decoration: InputDecoration(
                  hintText: _languageService.tr("chat.survey.title"),
                  filled: true,
                  fillColor: const Color(0xfff5f5f5),
                  hintStyle: const TextStyle(color: Color(0xFF9CA3AF), fontSize: 12),
                  contentPadding: const EdgeInsets.symmetric(horizontal: 12, vertical: 14),
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(15),
                    borderSide: BorderSide.none,
                  ),
                ),
                onChanged: (val) => surveyTitle.value = val,
              ),
              const SizedBox(height: 20),
              Obx(() => Row(
                children: [
                  Checkbox(
                    value: isMultipleChoice.value,
                    onChanged: (value) => isMultipleChoice.value = value ?? false,
                    activeColor: Color(0xffED7474),
                  ),
                  Text(
                    _languageService.tr("chat.survey.multipleChoice"),
                    style: TextStyle(fontSize: 12),
                  ),
                ],
              )),
              const SizedBox(height: 30),
              Obx(() => Column(
                children: List.generate(surveyChoices.length, (index) {
                  return Padding(
                    padding: const EdgeInsets.only(bottom: 8.0),
                    child: Row(
                      children: [
                        Expanded(
                          child: TextField(
                            style: TextStyle(fontSize: 12),
                            decoration: InputDecoration(
                              hintText: _languageService.tr("chat.survey.addChoice"),
                              filled: true,
                              fillColor: const Color(0xfff5f5f5),
                              hintStyle: const TextStyle(color: Color(0xFF9CA3AF), fontSize: 12),
                              contentPadding: const EdgeInsets.symmetric(horizontal: 12, vertical: 14),
                              border: OutlineInputBorder(
                                borderRadius: BorderRadius.circular(15),
                                borderSide: BorderSide.none,
                              ),
                            ),
                            onChanged: (val) => surveyChoices[index] = val,
                          ),
                        ),
                        const SizedBox(width: 8),
                        if (surveyChoices.length > 2)
                          IconButton(
                            icon: const Icon(Icons.remove_circle),
                            onPressed: () => surveyChoices.removeAt(index),
                          ),
                      ],
                    ),
                  );
                }),
              )),
              TextButton.icon(
                onPressed: () => surveyChoices.add(''),
                icon: const Icon(
                  Icons.add,
                  color: Color(0xffED7474),
                  size: 15,
                ),
                label: Text(
                  _languageService.tr("chat.survey.addChoice"),
                  style: TextStyle(color: Color(0xffED7474), fontSize: 12),
                ),
              ),
              const SizedBox(height: 30),
              CustomButton(
                text: _languageService.tr("chat.survey.send"),
                height: 45,
                borderRadius: 15,
                onPressed: () {
                  final filledChoices = surveyChoices.where((e) => e.trim().isNotEmpty).toList();
                  if (surveyTitleController.text.trim().isNotEmpty && filledChoices.length >= 2) {
                    sendSurvey(surveyTitleController.text, filledChoices);
                    Get.back();
                  }
                },
                isLoading: isSendingMessage,
                backgroundColor: Color(0xffFFF6F6),
                textColor: Color(0xffED7474),
              ),
              const SizedBox(height: 20),
            ],
          ),
        ),
      ),
      isScrollControlled: true,
    );
  }

  void sendSurvey(String title, List<String> choices) async {
    if (isSendingMessage.value) return;
    
    isSendingMessage.value = true;
    
    try {
      debugPrint('üìä Survey g√∂nderme ba≈ülatƒ±lƒ±yor...');
      debugPrint('üìä Group ID: ${currentGroupId.value}');
      debugPrint('üìä Title: $title');
      debugPrint('üìä Choices: $choices');
      debugPrint('üìä Multiple Choice: ${isMultipleChoice.value}');
      
      final success = await SurveyService.createSurvey(
        receiverId: int.parse(currentGroupId.value),
        isGroup: true,
        title: title,
        multipleChoice: isMultipleChoice.value,
        choices: choices,
      );
      
      if (success) {
        // Ba≈üarƒ±lƒ± ise mesajlarƒ± yeniden y√ºkle
        await refreshMessagesOnly();
        
        // Survey g√∂nderildikten sonra en alta git
        WidgetsBinding.instance.addPostFrameCallback((_) {
          scrollToBottom(animated: true);
        });
        
        Get.snackbar(
          'Ba≈üarƒ±lƒ±',
          'Anket ba≈üarƒ±yla g√∂nderildi',
          snackPosition: SnackPosition.BOTTOM,
          backgroundColor: Colors.green,
          colorText: Colors.white,
        );
      } else {
        Get.snackbar(
          'Hata',
          'Anket g√∂nderilemedi',
          snackPosition: SnackPosition.BOTTOM,
        );
      }
    } catch (e) {
      debugPrint('Survey g√∂nderme hatasƒ±: $e');
      Get.snackbar(
        'Hata',
        'Anket g√∂nderilemedi',
        snackPosition: SnackPosition.BOTTOM,
      );
    } finally {
      isSendingMessage.value = false;
    }
  }

  void answerSurvey(int surveyId, List<String> selectedChoices) async {
    try {
      // Se√ßilen choice'larƒ±n ID'lerini bul
      List<int> answerIds = [];
      
      // String olarak gelen choice ID'lerini int'e √ßevir
      for (String choice in selectedChoices) {
        final choiceId = int.tryParse(choice);
        if (choiceId != null) {
          answerIds.add(choiceId);
        }
      }
      
      final success = await SurveyService.answerSurvey(
        surveyId: surveyId,
        answerIds: answerIds,
      );
      
      if (success) {
        // Ba≈üarƒ±lƒ± ise mesajlarƒ± yeniden y√ºkle
        await refreshMessagesOnly();
      } else {
        Get.snackbar(
          'Hata',
          'Anket cevabƒ± kaydedilemedi',
          snackPosition: SnackPosition.BOTTOM,
        );
      }
    } catch (e) {
      debugPrint('Survey cevaplama hatasƒ±: $e');
      Get.snackbar(
        'Hata',
        'Anket cevabƒ± kaydedilemedi',
        snackPosition: SnackPosition.BOTTOM,
      );
    }
  }

  void pickImageFromGallery() async {
    final pickedFile =
        await ImagePicker().pickImage(source: ImageSource.gallery);
    if (pickedFile != null) {
      final file = File(pickedFile.path);
      selectedFiles.add(file);
    }
  }

  void pickDocument() async {
    try {
      FilePickerResult? result = await FilePicker.platform.pickFiles(
        type: FileType.custom,
        allowedExtensions: ['pdf', 'doc', 'docx', 'txt'],
      );

      if (result != null && result.files.single.path != null) {
        final filePath = result.files.single.path!;
        final file = File(filePath);
        selectedFiles.add(file);
        
        debugPrint("Se√ßilen dosya: $filePath");
      }
    } catch (e) {
      debugPrint("Belge se√ßme hatasƒ±: $e",wrapWidth: 1024);
    }
  }

  Future<void> sendMessage(String text) async {
    if (isSendingMessage.value) return;
    
    debugPrint('üì§ Sending message: "$text"');
    
    if (text.isEmpty && selectedFiles.isEmpty) {
      debugPrint('‚ùå Nothing to send');
      return;
    }
    
    if (text.isEmpty && selectedFiles.isNotEmpty) {
      debugPrint('üìÅ Sending only media files');
      await sendMediaOnly();
      return;
    }
    
    // Socket durumunu kontrol et
    debugPrint('üîå Socket durumu kontrol ediliyor...');
    debugPrint('üîå Socket baƒülƒ±: ${_socketService.isConnected.value}');
    debugPrint('üîå Socket ID: ${_socketService.socket?.id}');
    debugPrint('üîå Group Message Subscription aktif: ${!_groupMessageSubscription.isPaused}');
    
    isSendingMessage.value = true;
    
    try {
      bool success;
      
      if (text.isNotEmpty && hasLinksInText(text)) {
        debugPrint('üîó Links detected in text, processing...');
        
        final urls = extractUrlsFromText(text);
        final nonLinkText = extractNonLinkText(text);
        final normalizedUrls = urls.map((url) => normalizeUrl(url)).toList();
        
        success = await _groupServices.sendGroupMessage(
          groupId: currentGroupId.value,
          message: nonLinkText,
          mediaFiles: selectedFiles.isNotEmpty ? selectedFiles : null,
          links: normalizedUrls,
        );
      } else {
        success = await _groupServices.sendGroupMessage(
          groupId: currentGroupId.value,
          message: text,
          mediaFiles: selectedFiles.isNotEmpty ? selectedFiles : null,
          links: null,
        );
      }
      
      if (success) {
        selectedFiles.clear();
        
        // Socket √ºzerinden mesaj gelip gelmediƒüini kontrol et
        debugPrint('‚úÖ Mesaj ba≈üarƒ±yla g√∂nderildi, socket √ºzerinden gelmesi bekleniyor...');
        
        // Socket √ºzerinden mesaj gelmesi i√ßin kƒ±sa bir s√ºre bekle
        bool socketMessageReceived = false;
        final originalMessageCount = messages.length;
        
        // 2 saniye boyunca socket mesajƒ±nƒ± bekle
        for (int i = 0; i < 20; i++) {
          await Future.delayed(Duration(milliseconds: 100));
          if (messages.length > originalMessageCount) {
            debugPrint('‚úÖ Socket √ºzerinden yeni mesaj geldi!');
            socketMessageReceived = true;
            break;
          }
        }
        
        if (!socketMessageReceived) {
          debugPrint('‚ö†Ô∏è Socket √ºzerinden mesaj gelmedi, API\'den yeniden y√ºklenecek...');
        }
        
        // FIXED: Immediate scroll for better UX, then refresh
        scrollToBottomForNewMessage();
        
        // OPTIMIZE: Reduced refresh delay
        Future.delayed(Duration(milliseconds: 300), () async {
          await refreshMessagesOptimized();
          // Ensure we stay at bottom after refresh
          scrollToBottomForNewMessage();
        });
      } else {
        Get.snackbar(
          _languageService.tr('groupChat.errors.messageSendFailed'),
          _languageService.tr('groupChat.errors.tryAgain'),
          snackPosition: SnackPosition.BOTTOM
        );
      }
      
    } catch (e) {
      debugPrint('üí• Message sending error: $e');
      Get.snackbar(
        _languageService.tr('groupChat.errors.messageSendFailed'),
        _languageService.tr('groupChat.errors.tryAgain'),
        snackPosition: SnackPosition.BOTTOM
      );
    } finally {
      isSendingMessage.value = false;
    }
  }

  // Sadece media dosyalarƒ±nƒ± g√∂nder (text olmadan)
  Future<void> sendMediaOnly() async {
    if (isSendingMessage.value) return;
    
    debugPrint('üìÅ Sending media files only');
    isSendingMessage.value = true;
    
    try {
      final success = await _groupServices.sendGroupMessage(
        groupId: currentGroupId.value,
        message: '', // Bo≈ü text
        mediaFiles: selectedFiles,
        links: null,
      );
      
      if (success) {
        selectedFiles.clear();
        
        // FIXED: Same scroll behavior for media
        scrollToBottomForNewMessage();
        
        Future.delayed(Duration(milliseconds: 300), () async {
          await refreshMessagesOptimized();
          scrollToBottomForNewMessage();
        });
      } else {
        Get.snackbar(
          _languageService.tr('groupChat.errors.messageSendFailed'),
          _languageService.tr('groupChat.errors.tryAgain'),
          snackPosition: SnackPosition.BOTTOM
        );
      }
      
    } catch (e) {
      debugPrint('üí• Media sending error: $e');
      Get.snackbar(
        _languageService.tr('groupChat.errors.messageSendFailed'),
        _languageService.tr('groupChat.errors.tryAgain'),
        snackPosition: SnackPosition.BOTTOM
      );
    } finally {
      isSendingMessage.value = false;
    }
  }

  void clearSelectedItems() {
    selectedFiles.clear();
  }

  void scrollToBottom({bool animated = true}) {
    try {
      if (scrollController.hasClients && 
          scrollController.position.hasContentDimensions &&
          messages.isNotEmpty) {
        
        final maxScroll = scrollController.position.maxScrollExtent;
        debugPrint('üìú Group Chat - Scrolling to bottom: maxScroll = $maxScroll');
        
        if (animated) {
          scrollController.animateTo(
            maxScroll,
            duration: Duration(milliseconds: 300),
            curve: Curves.easeOut,
          );
        } else {
          scrollController.jumpTo(maxScroll);
        }
      } else {
        debugPrint('‚ö†Ô∏è Group Chat - Cannot scroll: hasClients=${scrollController.hasClients}, messages=${messages.length}');
      }
    } catch (e) {
      debugPrint('‚ùå Group Chat - Scroll error: $e');
    }
  }

  void getToGrupDetailScreen() {
    debugPrint('üîç Navigating to group detail screen with group ID: ${currentGroupId.value}');
    Get.toNamed("/groupDetailScreen", arguments: {
      'groupId': currentGroupId.value,
    });
  }

  // OPTIMIZE: Faster message refresh
  Future<void> refreshMessagesOptimized() async {
    try {
      debugPrint('üîÑ Refreshing messages (optimized)...');
      
      // Reduced timeout for faster response
      final group = await _groupServices.fetchGroupDetail(currentGroupId.value)
          .timeout(const Duration(seconds: 15)); // 5'ten 15'e √ßƒ±karƒ±ldƒ±
      
      groupData.value = group;
      convertGroupChatsToMessagesOptimized();
      
      // Socket √ºzerinden pin durumlarƒ±nƒ± kontrol et
      await _checkPinStatusFromSocket();
      
      debugPrint('‚úÖ Messages refreshed successfully');
    } catch (e) {
      debugPrint('‚ùå Error refreshing messages: $e');
    }
  }

  // Keep backwards compatibility
  Future<void> refreshMessagesOnly() async {
    await refreshMessagesOptimized();
  }

  /// Pin message update handler - socket'ten gelen pin/unpin event'lerini i≈üle
  void _onPinMessageUpdate(dynamic data) {
    try {
      debugPrint('üìå [GroupChatDetailController] Pin message update received: $data');
      debugPrint('üìå [GroupChatDetailController] Data type: ${data.runtimeType}');
      debugPrint('üìå [GroupChatDetailController] Data keys: ${data is Map ? data.keys.toList() : 'Not a Map'}');
      
      if (data is Map<String, dynamic>) {
        // Pin durumu kontrol√º response'u mu kontrol et
        if (data.containsKey('pinned_messages') || data.containsKey('pin_status')) {
          _handlePinStatusResponse(data);
          return;
        }
        
        // Group chat i√ßin √∂zel event kontrol√º
        if (data.containsKey('group_id')) {
          final groupId = data['group_id']?.toString();
          final messageId = data['message_id']?.toString();
          final isPinned = data['is_pinned'] ?? false;
          
          debugPrint('üìå [GroupChatDetailController] Group chat pin event detected');
          debugPrint('üìå [GroupChatDetailController] Group ID: $groupId, Message ID: $messageId, Is Pinned: $isPinned');
          debugPrint('üìå [GroupChatDetailController] Current Group ID: ${currentGroupId.value}');
          
          // Sadece bu grup i√ßin gelen pin event'lerini i≈üle
          if (groupId != null && groupId == currentGroupId.value && messageId != null) {
            _updateMessagePinStatus(messageId, isPinned);
            return;
          } else {
            debugPrint('üìå [GroupChatDetailController] Pin event not for this group. Group ID: $groupId, Current: ${currentGroupId.value}');
            return;
          }
        }
        
        // Yeni pin event yapƒ±sƒ± kontrol√º (SocketService'den gelen)
        if (data.containsKey('source') && data['source'] == 'group:chat_message') {
          _handleSocketPinUpdate(data);
          return;
        }
        
        // Yeni: group:unpin_message event kontrol√º
        if (data.containsKey('source') && data['source'] == 'group:unpin_message') {
          _handleSocketUnpinUpdate(data);
          return;
        }
        
        // Action kontrol√º (unpin i≈ülemi i√ßin)
        if (data.containsKey('action') && data['action'] == 'unpin') {
          _handleSocketUnpinUpdate(data);
          return;
        }
        
        // Event yapƒ±sƒ±nƒ± kontrol et - message objesi i√ßinde olabilir
        Map<String, dynamic> messageData;
        if (data.containsKey('message')) {
          // message alanƒ±nƒ±n Map olup olmadƒ±ƒüƒ±nƒ± kontrol et
          if (data['message'] is Map<String, dynamic>) {
            messageData = data['message'] as Map<String, dynamic>;
            debugPrint('üìå [GroupChatDetailController] Message data found in nested structure');
          } else {
            // message alanƒ± Map deƒüilse, direkt data'yƒ± kullan
            messageData = data;
            debugPrint('üìå [GroupChatDetailController] Message data found in direct structure (message not a Map)');
          }
        } else {
          messageData = data;
          debugPrint('üìå [GroupChatDetailController] Message data found in direct structure');
        }
        
        final messageId = messageData['id']?.toString();
        final isPinned = messageData['is_pinned'] ?? false;
        final groupId = messageData['group_id']?.toString();
        
        debugPrint('üìå [GroupChatDetailController] Parsed data - Message ID: $messageId, Group ID: $groupId, Is Pinned: $isPinned');
        debugPrint('üìå [GroupChatDetailController] Current Group ID: ${currentGroupId.value}');
        
        // Sadece bu grup i√ßin gelen pin event'lerini i≈üle
        if (groupId != null && groupId == currentGroupId.value && messageId != null) {
          _updateMessagePinStatus(messageId, isPinned);
        } else {
          debugPrint('üìå [GroupChatDetailController] Pin event not for this group. Group ID: $groupId, Current: ${currentGroupId.value}');
        }
      }
    } catch (e) {
      debugPrint('‚ùå [GroupChatDetailController] Pin message update error: $e');
    }
  }

  /// Socket'ten gelen unpin g√ºncellemelerini i≈üle
  void _handleSocketUnpinUpdate(Map<String, dynamic> data) {
    try {
      debugPrint('üìå [GroupChatDetailController] Socket unpin update handling...');
      
      final messageId = data['message_id']?.toString();
      final groupId = data['group_id']?.toString();
      final isPinned = data['is_pinned'] ?? false;
      final timestamp = data['timestamp'];
      final source = data['source'];
      final action = data['action'];
      
      debugPrint('üìå [GroupChatDetailController] Socket unpin update - Message ID: $messageId, Group ID: $groupId, Is Pinned: $isPinned');
      debugPrint('üìå [GroupChatDetailController] Socket unpin update - Source: $source, Action: $action, Timestamp: $timestamp');
      
      // Sadece bu grup i√ßin gelen unpin event'lerini i≈üle
      if (groupId != null && groupId == currentGroupId.value && messageId != null) {
        debugPrint('üìå [GroupChatDetailController] Processing unpin for message $messageId');
        _updateMessagePinStatus(messageId, isPinned);
        
        // Unpin i≈ülemi i√ßin √∂zel i≈ülem
        debugPrint('üìå [GroupChatDetailController] Unpin operation detected - Forcing PinnedMessagesWidget refresh');
        Future.delayed(Duration(milliseconds: 200), () {
          update();
          debugPrint('üìå [GroupChatDetailController] PinnedMessagesWidget forced refresh after unpin');
        });
      } else {
        debugPrint('üìå [GroupChatDetailController] Socket unpin event not for this group. Group ID: $groupId, Current: ${currentGroupId.value}');
      }
    } catch (e) {
      debugPrint('‚ùå [GroupChatDetailController] Socket unpin update error: $e');
    }
  }

  /// Socket'ten gelen pin g√ºncellemelerini i≈üle
  void _handleSocketPinUpdate(Map<String, dynamic> data) {
    try {
      debugPrint('üìå [GroupChatDetailController] Socket pin update handling...');
      
      final messageId = data['message_id']?.toString();
      final groupId = data['group_id']?.toString();
      final isPinned = data['is_pinned'] ?? false;
      final timestamp = data['timestamp'];
      final source = data['source'];
      
      debugPrint('üìå [GroupChatDetailController] Socket pin update - Message ID: $messageId, Group ID: $groupId, Is Pinned: $isPinned');
      debugPrint('üìå [GroupChatDetailController] Socket pin update - Source: $source, Timestamp: $timestamp');
      
      // Sadece bu grup i√ßin gelen pin event'lerini i≈üle
      if (groupId != null && groupId == currentGroupId.value && messageId != null) {
        _updateMessagePinStatus(messageId, isPinned);
      } else {
        debugPrint('üìå [GroupChatDetailController] Socket pin event not for this group. Group ID: $groupId, Current: ${currentGroupId.value}');
      }
    } catch (e) {
      debugPrint('‚ùå [GroupChatDetailController] Socket pin update error: $e');
    }
  }

  /// Mesaj pin durumunu g√ºncelle (ortak metod)
  void _updateMessagePinStatus(String messageId, bool isPinned) {
    try {
      debugPrint('üìå [GroupChatDetailController] Updating message pin status...');
      debugPrint('üìå [GroupChatDetailController] Message ID: $messageId, Is Pinned: $isPinned');
      debugPrint('üìå [GroupChatDetailController] Current messages count: ${messages.length}');
      
      // Mesajƒ± bul ve pin durumunu g√ºncelle
      final messageIndex = messages.indexWhere((msg) => msg.id == messageId);
      if (messageIndex != -1) {
        final existingMessage = messages[messageIndex];
        debugPrint('üìå [GroupChatDetailController] Found message at index $messageIndex');
        debugPrint('üìå [GroupChatDetailController] Current pin status: ${existingMessage.isPinned}');
        debugPrint('üìå [GroupChatDetailController] New pin status: $isPinned');
        
        if (existingMessage.isPinned != isPinned) {
          final updatedMessage = existingMessage.copyWith(isPinned: isPinned);
          messages[messageIndex] = updatedMessage;
          debugPrint('üìå [GroupChatDetailController] Message pin status updated successfully');
          
          // PinnedMessagesWidget'ƒ± g√ºncellemek i√ßin update() √ßaƒüƒ±r
          update();
          
          debugPrint('üìå [GroupChatDetailController] PinnedMessagesWidget update() called');
          debugPrint('üìå [GroupChatDetailController] Updated messages count: ${messages.length}');
          debugPrint('üìå [GroupChatDetailController] Pinned messages count: ${messages.where((m) => m.isPinned).length}');
          
          // Pin durumu deƒüi≈üikliƒüi i√ßin √∂zel log
          if (isPinned) {
            debugPrint('üìå [GroupChatDetailController] Message $messageId PINNED successfully');
          } else {
            debugPrint('üìå [GroupChatDetailController] Message $messageId UNPINNED successfully');
          }
          
          // PinnedMessagesWidget'ƒ±n anlƒ±k g√ºncellenmesi i√ßin ek bildirim
          _notifyPinnedMessagesUpdate();
          
          // Unpin i≈ülemi i√ßin √∂zel i≈ülem
          if (!isPinned) {
            debugPrint('üìå [GroupChatDetailController] UNPIN detected - Forcing PinnedMessagesWidget refresh');
            // Unpin durumunda widget'ƒ± zorla yenile
            Future.delayed(Duration(milliseconds: 100), () {
              update();
              debugPrint('üìå [GroupChatDetailController] PinnedMessagesWidget forced refresh after unpin');
            });
          }
        } else {
          debugPrint('üìå [GroupChatDetailController] Pin status unchanged, no update needed');
        }
      } else {
        debugPrint('‚ö†Ô∏è [GroupChatDetailController] Message with ID $messageId not found in current messages');
        debugPrint('‚ö†Ô∏è [GroupChatDetailController] Available message IDs: ${messages.map((m) => m.id).join(', ')}');
      }
    } catch (e) {
      debugPrint('‚ùå [GroupChatDetailController] Update message pin status error: $e');
    }
  }

  /// PinnedMessagesWidget g√ºncellemesi i√ßin bildirim g√∂nder
  void _notifyPinnedMessagesUpdate() {
    try {
      debugPrint('üìå [GroupChatDetailController] Notifying PinnedMessagesWidget update...');
      
      // PinnedMessagesWidget'ƒ±n anlƒ±k g√ºncellenmesi i√ßin √∂zel event
      final pinnedUpdateEvent = {
        'type': 'pinned_messages_update',
        'group_id': currentGroupId.value,
        'pinned_count': messages.where((m) => m.isPinned).length,
        'total_messages': messages.length,
        'timestamp': DateTime.now().millisecondsSinceEpoch,
      };
      
      debugPrint('üìå [GroupChatDetailController] Pinned messages update event: $pinnedUpdateEvent');
      
      // Widget'ƒ±n g√ºncellenmesi i√ßin update() √ßaƒüƒ±r
      update();
      
      debugPrint('üìå [GroupChatDetailController] PinnedMessagesWidget update notification sent');
    } catch (e) {
      debugPrint('‚ùå [GroupChatDetailController] Pinned messages update notification error: $e');
    }
  }

  /// Pin durumu response'larƒ±nƒ± i≈üle
  void _handlePinStatusResponse(Map<String, dynamic> data) {
    try {
      debugPrint('üìå [GroupChatDetailController] Handling pin status response: $data');
      
      // Pinned messages listesi varsa
      if (data.containsKey('pinned_messages')) {
        final pinnedMessages = data['pinned_messages'] as List<dynamic>? ?? [];
        debugPrint('üìå [GroupChatDetailController] Received ${pinnedMessages.length} pinned messages from socket');
        
        // T√ºm mesajlarƒ± √∂nce unpin yap
        for (int i = 0; i < messages.length; i++) {
          if (messages[i].isPinned) {
            messages[i] = messages[i].copyWith(isPinned: false);
          }
        }
        
        // Socket'ten gelen pinlenmi≈ü mesajlarƒ± pin yap
        for (final pinnedMsg in pinnedMessages) {
          if (pinnedMsg is Map<String, dynamic>) {
            final messageId = pinnedMsg['id']?.toString();
            if (messageId != null) {
              final messageIndex = messages.indexWhere((msg) => msg.id == messageId);
              if (messageIndex != -1) {
                messages[messageIndex] = messages[messageIndex].copyWith(isPinned: true);
                debugPrint('üìå [GroupChatDetailController] Message $messageId pinned from socket response');
              }
            }
          }
        }
        
        // UI'ƒ± g√ºncelle
        update();
        debugPrint('üìå [GroupChatDetailController] Pin status updated from socket response');
      }
      
      // Pin status update varsa
      if (data.containsKey('pin_status')) {
        final pinStatus = data['pin_status'] as Map<String, dynamic>?;
        if (pinStatus != null) {
          final messageId = pinStatus['message_id']?.toString();
          final isPinned = pinStatus['is_pinned'] ?? false;
          
          if (messageId != null) {
            final messageIndex = messages.indexWhere((msg) => msg.id == messageId);
            if (messageIndex != -1) {
              messages[messageIndex] = messages[messageIndex].copyWith(isPinned: isPinned);
              update();
              debugPrint('üìå [GroupChatDetailController] Message $messageId pin status updated: $isPinned');
            }
          }
        }
      }
      
    } catch (e) {
      debugPrint('‚ùå [GroupChatDetailController] Pin status response error: $e');
    }
  }

  /// API'den gelen pin durumlarini kontrol et ve UI'i guncelle
  void _updatePinStatusFromAPI() {
    try {
      debugPrint('üîç [GroupChatDetailController] API\'den gelen pin durumlari kontrol ediliyor...');
      
      final allMessages = messages;
      int pinnedCount = 0;
      
      for (int i = 0; i < allMessages.length; i++) {
        final message = allMessages[i];
        if (message.isPinned) {
          pinnedCount++;
          debugPrint('üîç [GroupChatDetailController] Pinlenmis mesaj bulundu: ID=${message.id}, Content="${message.content}"');
        }
      }
      
      debugPrint('üîç [GroupChatDetailController] API\'den gelen toplam pinlenmis mesaj sayisi: $pinnedCount');
      
      // UI'i guncelle
      if (pinnedCount > 0) {
        update();
        debugPrint('üîç [GroupChatDetailController] UI guncellendi - pinlenmis mesajlar gosteriliyor');
      }
      
    } catch (e) {
      debugPrint('‚ùå [GroupChatDetailController] API pin durumu kontrolu hatasi: $e');
    }
  }

  /// Socket √ºzerinden pin durumlarƒ±nƒ± kontrol et
  Future<void> _checkPinStatusFromSocket() async {
    try {
      debugPrint('üîç [GroupChatDetailController] Socket √ºzerinden pin durumlarƒ± kontrol ediliyor...');
      
      // Socket √ºzerinden pin durumlarƒ±nƒ± iste
      _socketService.sendMessage('group:get_pinned_messages', {
        'group_id': currentGroupId.value,
      });
      
      debugPrint('üîç [GroupChatDetailController] Pin durumu isteƒüi g√∂nderildi: group_id=${currentGroupId.value}');
      
      // Kƒ±sa bir bekleme s√ºresi (socket response i√ßin)
      await Future.delayed(Duration(milliseconds: 500));
      
      debugPrint('üîç [GroupChatDetailController] Pin durumu kontrol√º tamamlandƒ±');
      
    } catch (e) {
      debugPrint('‚ùå [GroupChatDetailController] Pin durumu kontrol√º hatasƒ±: $e');
    }
  }


  @override
  void onClose() {
    // Chat liste controller'ƒ±n group message listener'ƒ±nƒ± tekrar ba≈ülat (Artƒ±k gerekli deƒüil - s√ºrekli aktif)
    debugPrint('‚ñ∂Ô∏è ChatController group message listener artƒ±k ba≈ülatƒ±lmƒ±yor - s√ºrekli aktif');
    
    // Socket listener guard'ƒ± reset et
    _isSocketListenerSetup = false;
    
    messageController.dispose();
    pollTitleController.dispose();
    scrollController.dispose();
    _groupMessageSubscription.cancel();
    _pinMessageSubscription.cancel(); // Pin message subscription'ƒ± temizle

    _userCache.clear(); // Clear cache
    _lastMessageCount = 0; // Reset message count tracker
    super.onClose();
  }

  /// Pin or unpin a group message
  Future<void> pinMessage(int messageId) async {
    try {
      debugPrint('üìå [GroupChatDetailController] Pin/Unpin i≈ülemi ba≈ülatƒ±ldƒ±');
      debugPrint('üìå [GroupChatDetailController] Message ID: $messageId');
      debugPrint('üìå [GroupChatDetailController] Group ID: ${currentGroupId.value}');
      
      // Admin kontrol√º - API'den gelen verileri kullan
      debugPrint('üîç [GroupChatDetailController] === ADMIN YETKƒ∞ KONTROL√ú ===');
      debugPrint('üîç [GroupChatDetailController] isFounder: $isCurrentUserAdmin');
      debugPrint('üîç [GroupChatDetailController] isMember: ${groupData.value?.isMember}');
      debugPrint('üîç [GroupChatDetailController] User Count With Admin: ${groupData.value?.userCountWithAdmin}');
      debugPrint('üîç [GroupChatDetailController] User Count Without Admin: ${groupData.value?.userCountWithoutAdmin}');
      debugPrint('üîç [GroupChatDetailController] === ADMIN YETKƒ∞ KONTROL√ú TAMAMLANDI ===');
      
      // Mesaj detaylarƒ±nƒ± kontrol et
      final targetMessage = messages.firstWhereOrNull((msg) => msg.id == messageId.toString());
      if (targetMessage != null) {
        debugPrint('üîç [GroupChatDetailController] === MESAJ DETAYLARI ===');
        debugPrint('üîç [GroupChatDetailController] Message ID: ${targetMessage.id}');
        debugPrint('üîç [GroupChatDetailController] Message Content: ${targetMessage.content}');
        debugPrint('üîç [GroupChatDetailController] Current Pin Status: ${targetMessage.isPinned}');
        debugPrint('üîç [GroupChatDetailController] Message Type: ${targetMessage.messageType}');
        debugPrint('üîç [GroupChatDetailController] Sender ID: ${targetMessage.senderId}');
        debugPrint('üîç [GroupChatDetailController] === MESAJ DETAYLARI TAMAMLANDI ===');
      } else {
        debugPrint('‚ùå [GroupChatDetailController] Target message not found: $messageId');
      }
      
      if (!isCurrentUserAdmin) {
        debugPrint('‚ùå [GroupChatDetailController] User is not admin, cannot pin/unpin message');
        
        // TEST: Ge√ßici olarak admin kontrol√ºn√º devre dƒ±≈üƒ± bƒ±rak
        debugPrint('üîß [GroupChatDetailController] TEST: Admin kontrol√º devre dƒ±≈üƒ± bƒ±rakƒ±ldƒ±, i≈ülem devam ediyor...');
        
        // Get.snackbar(
        //   '‚ùå Yetki Hatasƒ±',
        //   'Sadece grup y√∂neticileri mesaj sabitleyebilir',
        //   snackPosition: SnackPosition.TOP,
        //   duration: Duration(seconds: 2),
        //   backgroundColor: Colors.red.shade100,
        //   colorText: Colors.red.shade900,
        // );
        // return;
      }
      
      // PinMessageService'i kullan
      final pinMessageService = Get.find<PinMessageService>();
      final success = await pinMessageService.pinGroupMessage(messageId, currentGroupId.value);
      
      if (success) {
        debugPrint('‚úÖ [GroupChatDetailController] Pin/Unpin i≈ülemi ba≈üarƒ±lƒ±');
        
        // UI g√ºncellemesi socket event'leri ile yapƒ±lacak
        // Burada manuel g√ºncelleme yapmaya gerek yok
      } else {
        debugPrint('‚ùå [GroupChatDetailController] Pin/Unpin i≈ülemi ba≈üarƒ±sƒ±z');
        
        // Hata bildirimi g√∂ster
        Get.snackbar(
          '‚ùå Hata',
          'Pin/Unpin i≈ülemi ba≈üarƒ±sƒ±z oldu',
          snackPosition: SnackPosition.TOP,
          duration: Duration(seconds: 2),
          backgroundColor: Colors.red.shade100,
          colorText: Colors.red.shade800,
        );
      }
    } catch (e) {
      debugPrint('‚ùå [GroupChatDetailController] Pin/Unpin i≈ülemi hatasƒ±: $e');
      
      // Hata bildirimi g√∂ster
      Get.snackbar(
        '‚ùå Hata',
        'Pin/Unpin i≈ülemi sƒ±rasƒ±nda hata olu≈ütu: $e',
        snackPosition: SnackPosition.TOP,
        duration: Duration(seconds: 2),
        backgroundColor: Colors.red.shade100,
        colorText: Colors.red.shade800,
      );
    }
  }
}
