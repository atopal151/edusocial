import 'dart:async';
import 'dart:io';
import 'package:file_picker/file_picker.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:image_picker/image_picker.dart';
import '../../components/buttons/custom_button.dart';
import '../../models/chat_models/group_message_model.dart';
import '../../models/group_models/group_detail_model.dart';
import '../../models/document_model.dart';
import '../../models/link_model.dart';
import '../../services/group_services/group_service.dart';
import '../../services/language_service.dart';
import '../../services/socket_services.dart';
import '../profile_controller.dart';
import 'chat_controller.dart'; // Added import for ChatController

class GroupChatDetailController extends GetxController {
  final LanguageService languageService = Get.find<LanguageService>();
  final GroupServices _groupServices = GroupServices();
  final RxList<GroupMessageModel> messages = <GroupMessageModel>[].obs;
  final RxBool isLoading = false.obs;
  final RxBool isGroupDataLoading = false.obs; // Grup verisi i√ßin ayrƒ± loading
  final RxBool isMessagesLoading = false.obs; // Mesajlar i√ßin ayrƒ± loading
  final RxString currentGroupId = ''.obs;
  final groupData = Rx<GroupDetailModel?>(null);
  final TextEditingController messageController = TextEditingController();

  // Socket service ile ilgili deƒüi≈ükenler
  late SocketService _socketService;
  late StreamSubscription _groupMessageSubscription;
  bool _isSocketListenerSetup = false; // Multiple subscription guard
  final ScrollController scrollController = ScrollController();

  // PAGINATION: New state variables for lazy loading group messages
  final RxBool isLoadingMoreMessages = false.obs;
  final RxBool hasMoreMessages = true.obs;
  final RxInt currentOffset = 0.obs;
  final int messagesPerPage = 1000; // Increased from 25 to 1000 to remove limit
  final RxBool isFirstLoad = true.obs;
  
  // Track message count for auto-scroll optimization
  int _lastMessageCount = 0;
  
  // Scroll to bottom button visibility
  final RxBool showScrollToBottomButton = false.obs;

  // Grup chat verilerinden √ßƒ±karƒ±lan belge, baƒülantƒ± ve fotoƒüraf listeleri
  final RxList<DocumentModel> groupDocuments = <DocumentModel>[].obs;
  final RxList<LinkModel> groupLinks = <LinkModel>[].obs;
  final RxList<String> groupPhotos = <String>[].obs;

  // Mesaj g√∂nderme i√ßin se√ßilen dosyalar ve linkler
  final RxList<File> selectedFiles = <File>[].obs;
  final RxBool isSendingMessage = false.obs;

  RxString pollQuestion = ''.obs;
  RxList<String> pollOptions = <String>[].obs;
  RxMap<String, int> pollVotes = <String, int>{}.obs;
  RxString selectedPollOption = ''.obs;
  TextEditingController pollTitleController = TextEditingController();

  // Performance optimization: Cache kullanƒ±cƒ± verileri
  final Map<String, Map<String, dynamic>> _userCache = {};
  bool _isInitialLoad = true;

  // URL algƒ±lama i√ßin regex pattern
  static final RegExp urlRegex = RegExp(
    r'(https?://[^\s]+)|(www\.[^\s]+)|([^\s]+\.[^\s]{2,})',
    caseSensitive: false,
  );

  // Link algƒ±lama fonksiyonu
  List<String> extractUrlsFromText(String text) {
    final matches = urlRegex.allMatches(text);
    return matches.map((match) => match.group(0)!).toList();
  }

  // URL'yi normalize et (http:// ekle)
  String normalizeUrl(String url) {
    if (!url.startsWith('http://') && !url.startsWith('https://')) {
      return 'https://$url';
    }
    return url;
  }

  // Mesaj i√ßeriƒüinde link var mƒ± kontrol et
  bool hasLinksInText(String text) {
    return urlRegex.hasMatch(text);
  }

  // Link olmayan text'i √ßƒ±kar
  String extractNonLinkText(String text) {
    return text.replaceAll(urlRegex, '').trim();
  }

  @override
  void onInit() {
    super.onInit();
    debugPrint('üîç Group chat detail controller onInit called');
    
    // Socket servisini initialize et
    _socketService = Get.find<SocketService>();
    _setupSocketListeners();
    
    // PAGINATION: Initialize scroll listener for lazy loading
    _setupPaginationScrollListener();
    
    if (Get.arguments != null && Get.arguments['groupId'] != null) {
      currentGroupId.value = Get.arguments['groupId'];
      debugPrint('‚úÖ Current group ID set to: ${currentGroupId.value}');
      
      // Optimize: Sadece burada y√ºkle, initState'te tekrar √ßaƒüƒ±rma
      _loadGroupDataProgressive();
      
      // Group chat'e girdiƒüinde socket durumunu kontrol et
      onGroupChatEntered();
      
      // Cache'i temizle (Android'de g√ºncel olmayan veri sorunu i√ßin)
      GroupServices.clearGroupCache();
    } else {
      debugPrint('‚ùå No group ID provided in arguments');
      Get.snackbar('Error', 'No group selected', snackPosition: SnackPosition.BOTTOM);
      Get.back();
    }
  }

  /// SCROLL: Setup scroll listener for scroll to bottom button
  void _setupPaginationScrollListener() {
    scrollController.addListener(() {
      // SCROLL TO BOTTOM BUTTON: Show/hide based on scroll position
      if (scrollController.hasClients && messages.isNotEmpty) {
        final maxScroll = scrollController.position.maxScrollExtent;
        final currentScroll = scrollController.position.pixels;
        final isNearBottom = (maxScroll - currentScroll) < 200; // Show button if user scrolled up more than 200px
        
        showScrollToBottomButton.value = !isNearBottom && maxScroll > 0;
      }
    });
  }



  /// Progressive loading: √ñnce grup verilerini y√ºkle, sonra mesajlarƒ±
  Future<void> _loadGroupDataProgressive() async {
    try {
      isGroupDataLoading.value = true;
      
      // STEP 1: Quick message loading (√∂nce sadece mesajlarƒ± al)
      await fetchGroupDetailsOptimized();
      
      isGroupDataLoading.value = false;
      
      // ƒ∞lk y√ºkleme sonrasƒ± scroll
      if (_isInitialLoad) {
        _isInitialLoad = false;
        WidgetsBinding.instance.addPostFrameCallback((_) {
          scrollToBottomAfterLoad();
        });
      }
      
    } catch (e) {
      debugPrint('‚ùå Progressive loading error: $e');
      isGroupDataLoading.value = false;
      isMessagesLoading.value = false;
    }
  }

  /// OPTIMIZED: Faster group details fetching
  Future<void> fetchGroupDetailsOptimized() async {
    if (currentGroupId.value.isEmpty) {
      debugPrint('‚ùå Cannot fetch group details: No group ID provided');
      return;
    }

    try {
      debugPrint('üöÄ Fast-fetching group details for group ID: ${currentGroupId.value}');
      
      // OPTIMIZE: Try cache first, then API
      GroupDetailModel? group;
      
      try {
        // Try cached version first
        group = await _groupServices.fetchGroupDetailCached(currentGroupId.value)
            .timeout(const Duration(seconds: 3)); // Even shorter timeout for cache
      } catch (e) {
        debugPrint('‚ö†Ô∏è Cache failed, trying direct API: $e');
        // Fallback to direct API call
        group = await _groupServices.fetchGroupDetail(currentGroupId.value)
            .timeout(const Duration(seconds: 5));
      }
      
      if (group != null) {
        groupData.value = group;
        
        // OPTIMIZE: Process messages in background
        Future.microtask(() {
          convertGroupChatsToMessagesOptimized();
        });
        
        debugPrint('‚úÖ Group details loaded successfully (optimized)');
      }
      
    } catch (e) {
      debugPrint('‚ùå Error fetching group details: $e');
      
      Get.snackbar(
        'Baƒülantƒ± Hatasƒ±',
        'Grup verileri y√ºklenemedi. L√ºtfen tekrar deneyin.',
        snackPosition: SnackPosition.BOTTOM,
        duration: Duration(seconds: 3),
        backgroundColor: Colors.orange.shade100,
        colorText: Colors.orange.shade800,
      );
    }
  }

  /// Socket event dinleyicilerini ayarla
  void _setupSocketListeners() {
    // Multiple subscription guard
    if (_isSocketListenerSetup) {
      debugPrint('‚ö†Ô∏è Group chat socket listeners already setup, skipping...');
      return;
    }
    
    // Chat liste controller'ƒ±n group message listener'ƒ±nƒ± durdur
    try {
      final chatController = Get.find<ChatController>();
      chatController.pauseGroupMessageListener();
      debugPrint('üì¥ ChatController group message listener duraklatƒ±ldƒ±');
    } catch (e) {
      debugPrint('‚ö†Ô∏è ChatController bulunamadƒ±: $e');
    }
    
    // Group mesaj dinleyicisi - user:{user_id} kanalƒ±ndan
    _groupMessageSubscription = _socketService.onGroupMessage.listen((data) {
      _onNewGroupMessage(data);
    });
    
    _isSocketListenerSetup = true;
    debugPrint('‚úÖ GroupChatDetailController socket listeners setup completed');
  }

  /// Group message listener'ƒ±nƒ± duraklat
  void pauseGroupMessageListener() {
    try {
      debugPrint('‚è∏Ô∏è PAUSE REQUEST: GroupChatDetailController group message listener pause requested');
      debugPrint('‚è∏Ô∏è Current state: isPaused=${_groupMessageSubscription.isPaused}');
      
      if (!_groupMessageSubscription.isPaused) {
        _groupMessageSubscription.pause();
        debugPrint('‚è∏Ô∏è SUCCESS: GroupChatDetailController group message listener paused');
      } else {
        debugPrint('‚è∏Ô∏è ALREADY PAUSED: GroupChatDetailController group message listener was already paused');
      }
      
      // Verification
      debugPrint('‚è∏Ô∏è VERIFICATION: isPaused=${_groupMessageSubscription.isPaused}');
      
    } catch (e) {
      debugPrint('‚ùå PAUSE ERROR: Group message listener pause failed: $e');
    }
  }

  /// Group message listener'ƒ±nƒ± devam ettir
  void resumeGroupMessageListener() {
    try {
      debugPrint('‚ñ∂Ô∏è RESUME REQUEST: GroupChatDetailController group message listener resume requested');
      debugPrint('‚ñ∂Ô∏è Current state: isPaused=${_groupMessageSubscription.isPaused}');
      
      if (_groupMessageSubscription.isPaused) {
        _groupMessageSubscription.resume();
        debugPrint('‚ñ∂Ô∏è SUCCESS: GroupChatDetailController group message listener resumed');
      } else {
        debugPrint('‚ñ∂Ô∏è ALREADY ACTIVE: GroupChatDetailController group message listener was already active');
      }
      
      // Verification  
      debugPrint('‚ñ∂Ô∏è VERIFICATION: isPaused=${_groupMessageSubscription.isPaused}');
      
    } catch (e) {
      debugPrint('‚ùå RESUME ERROR: Group message listener resume failed: $e');
    }
  }

  /// Yeni grup mesajƒ± geldiƒüinde i≈üle - OPTIMIZE
  void _onNewGroupMessage(dynamic data) {
    try {
      debugPrint('üì° GroupChatDetailController - Yeni grup mesajƒ± geldi: $data');
      
      if (data is Map<String, dynamic>) {
        final incomingGroupId = data['group_id']?.toString();
        
        // Sadece bu grup i√ßin gelen mesajlarƒ± i≈üle
        if (incomingGroupId != null && incomingGroupId == currentGroupId.value) {
          debugPrint('‚úÖ Yeni grup mesajƒ± bu gruba ait, mesaj listesine ekleniyor');
          
          // OPTIMIZE: T√ºm grup detayƒ±nƒ± tekrar √ßekme, sadece yeni mesajƒ± ekle
          _addNewMessageFromSocket(data);
          
          debugPrint('‚úÖ Yeni grup mesajƒ± i≈ülendi');
        } else {
          debugPrint('üì° Gelen grup mesajƒ± bu gruba ait deƒüil. Gelen: $incomingGroupId, Mevcut: ${currentGroupId.value}');
        }
      }
    } catch (e) {
      debugPrint('‚ùå _onNewGroupMessage error: $e');
    }
  }

  /// Socket'ten gelen yeni mesajƒ± direkt ekle (API √ßaƒürƒ±sƒ± yapma)
  void _addNewMessageFromSocket(Map<String, dynamic> data) {
    try {
      debugPrint('üì° [GroupChatDetailController] Yeni grup mesajƒ± payload alƒ±ndƒ±');
      debugPrint('üì° [GroupChatDetailController] Current Group ID: ${currentGroupId.value}');
      debugPrint('üì° [GroupChatDetailController] Processing: $data');
      
      // Yeni mesajƒ± parse et ve listeye ekle
      final currentUserId = Get.find<ProfileController>().userId.value;
      
      // DUPLICATE CHECK: Aynƒ± ID'li mesaj var mƒ± kontrol et
      final messageId = data['id']?.toString() ?? DateTime.now().millisecondsSinceEpoch.toString();
      final isDuplicate = messages.any((existingMessage) => existingMessage.id == messageId);
      if (isDuplicate) {
        debugPrint('üö´ [GroupChatDetailController] DUPLICATE MESSAGE BLOCKED: ID $messageId already exists');
        return;
      }
      
      // Basit implementasyon - ger√ßek socket data'ya g√∂re ayarlanmalƒ±
      final newMessage = GroupMessageModel(
        id: messageId,
        senderId: data['user_id']?.toString() ?? '',
        receiverId: currentGroupId.value,
        name: data['user']?['name'] ?? '',
        surname: data['user']?['surname'] ?? '',
        username: data['user']?['username'] ?? '',
        profileImage: data['user']?['avatar_url'] ?? '',
        content: data['message'] ?? '',
        messageType: GroupMessageType.text, // Socket data'ya g√∂re ayarla
        timestamp: DateTime.now(),
        isSentByMe: data['user_id']?.toString() == currentUserId,
      );
      
      messages.add(newMessage);
      debugPrint('‚úÖ [GroupChatDetailController] Yeni grup mesajƒ± eklendi: ID ${newMessage.id}, Content: "${newMessage.content}"');
      debugPrint('‚úÖ [GroupChatDetailController] Toplam grup mesaj sayƒ±sƒ±: ${messages.length}');
      
      // Yeni mesaj eklendiƒüinde en alta git
      WidgetsBinding.instance.addPostFrameCallback((_) {
        scrollToBottomForNewMessage();
      });
      
    } catch (e) {
      debugPrint('‚ùå [GroupChatDetailController] _addNewMessageFromSocket error: $e');
      // Fallback: T√ºm mesajlarƒ± yeniden y√ºkle
      refreshMessagesOnly();
    }
  }

  /// Group chat socket durumunu kontrol et
  void checkGroupChatSocketConnection() {
    debugPrint('üì° === GROUP CHAT SOCKET DURUM RAPORU ===');
    debugPrint('üì° Socket Baƒülantƒ± Durumu: ${_socketService.isConnected.value}');
    debugPrint('üì° Aktif Group ID: ${currentGroupId.value}');
    debugPrint('üì° Group Message Subscription Aktif: ${!_groupMessageSubscription.isPaused}');
    debugPrint('üì° Socket ID: ${_socketService.socket?.id}');
    debugPrint('üì° Socket Connected: ${_socketService.socket?.connected}');
    
    // Socket service'den detaylƒ± durum raporu al
    _socketService.checkSocketStatus();
    
    debugPrint('üì° =======================================');
  }

  /// Group chat'e girdiƒüinde socket durumunu kontrol et
  void onGroupChatEntered() {
    debugPrint('üö™ Group chat\'e girildi, socket durumu kontrol ediliyor...');
    checkGroupChatSocketConnection();
    
    // Group chat'e girdiƒüinde socket'e join ol
    if (_socketService.isConnected.value) {
      debugPrint('üîå Group chat i√ßin socket kanalƒ±na join olunuyor...');
      _socketService.sendMessage('join', {
        'channel': 'group:${currentGroupId.value}',
        'group_id': currentGroupId.value,
        'user_id': Get.find<ProfileController>().userId.value,
      });
      
      // Test i√ßin manuel socket event g√∂nder
      _testSocketEvent();
    }
  }

  /// Test i√ßin manuel socket event g√∂nder
  void _testSocketEvent() {
    debugPrint('üß™ Test socket event g√∂nderiliyor...');
    _socketService.sendTestEvent('user:group_message', {
      'group_id': currentGroupId.value,
      'user_id': Get.find<ProfileController>().userId.value,
      'message': 'Test mesajƒ± - ${DateTime.now()}',
      'created_at': DateTime.now().toIso8601String(),
    });
  }

  /// OPTIMIZE: Background message conversion with pagination support
  Future<void> convertGroupChatsToMessagesOptimized() async {
    if (groupData.value?.groupChats == null) return;
    
    try {
      final groupChats = groupData.value!.groupChats;
      final currentUserId = Get.find<ProfileController>().userId.value;
      
      // PAGINATION: Process all messages without limit
      final messagesToProcess = groupChats;
      
      // Performance: Batch processing
      final processedMessages = <GroupMessageModel>[];
      
      // Cache kullanƒ±cƒ± verilerini tek seferde
      for (final chat in messagesToProcess) {
        final userId = chat.userId.toString();
        if (!_userCache.containsKey(userId)) {
          _userCache[userId] = chat.user;
        }
      }
      
      // OPTIMIZE: Process in smaller batches to prevent UI freeze
      const batchSize = 10;
      for (int i = 0; i < messagesToProcess.length; i += batchSize) {
        final batch = messagesToProcess.skip(i).take(batchSize);
        
        for (final chat in batch) {
          try {
            final userId = chat.userId.toString();
            final user = _userCache[userId]!;
            final isSentByMe = userId == currentUserId;
            
            // FIXED: Safe message type determination
            final messageData = _determineMessageType(chat);
            
            final message = GroupMessageModel(
              id: chat.id.toString(),
              senderId: userId,
              receiverId: chat.groupId.toString(),
              name: user['name'] ?? '',
              surname: user['surname'] ?? '',
              username: user['username'] ?? user['name'] ?? '',
              profileImage: user['avatar_url'] ?? '',
              content: messageData['content'],
              messageType: messageData['type'],
              timestamp: DateTime.parse(chat.createdAt),
              isSentByMe: isSentByMe,
              pollOptions: messageData['pollOptions'],
              additionalText: messageData['additionalText'],
              links: messageData['links'],
            );
            
            processedMessages.add(message);
          } catch (e) {
            debugPrint('‚ö†Ô∏è Error processing message ${chat.id}: $e');
            // Skip this message and continue
          }
        }
        
        // Allow UI to update between batches
        if (i + batchSize < messagesToProcess.length) {
          await Future.delayed(Duration(milliseconds: 1));
        }
      }
      
      // FIXED: API'den gelen mesajlar zaten doƒüru sƒ±ralƒ± (en yeni en altta)
      // Sadece timestamp'e g√∂re sƒ±rala (en eski en √ºstte, en yeni en altta)
      processedMessages.sort((a, b) => a.timestamp.compareTo(b.timestamp));
      
      // PAGINATION: Update state based on first load or not
      if (isFirstLoad.value) {
        messages.assignAll(processedMessages);
        
        // Since we're loading all messages, no more messages to load
        hasMoreMessages.value = false;
        
        isFirstLoad.value = false;
        debugPrint('‚úÖ Initial ${processedMessages.length} group messages loaded (proper chronological order)');
      debugPrint('üìä Mesaj sayƒ±sƒ± kontrol√º: ${messages.length} mesaj y√ºklendi');
      } else {
        messages.assignAll(processedMessages);
        debugPrint('üìä Mesaj sayƒ±sƒ± g√ºncellendi: ${messages.length} mesaj');
      }
      
      // Extract media in background
      Future.microtask(() {
        extractGroupChatMedia();
      });
      
      debugPrint('‚úÖ Processed ${processedMessages.length} messages successfully');
      
    } catch (e) {
      debugPrint('‚ùå Error in convertGroupChatsToMessagesOptimized: $e');
    }
  }

  /// Helper function for message type determination - FIXED
  Map<String, dynamic> _determineMessageType(dynamic chat) {
    GroupMessageType messageType = GroupMessageType.text;
    String content = chat.message ?? '';
    List<String>? links;
    List<String>? pollOptions;
    String? additionalText;
    
    try {
      if (chat.messageType == 'poll') {
        messageType = GroupMessageType.poll;
        content = chat.message ?? '';
        pollOptions = ['Se√ßenek 1', 'Se√ßenek 2']; // TODO: Backend'den parse et
      } else if (chat.media != null && chat.media.isNotEmpty) {
        final media = chat.media.first;
        if (media.type != null && media.type.toString().startsWith('image/')) {
          messageType = GroupMessageType.image;
          content = media.fullPath ?? '';
        } else {
          messageType = GroupMessageType.document;
          content = media.fullPath ?? '';
        }
      } else if (chat.groupChatLink != null && chat.groupChatLink.isNotEmpty) {
        // FIXED: Safe type casting for links
        final chatLinks = <String>[];
        
        for (var link in chat.groupChatLink) {
          if (link?.link != null) {
            final linkStr = link.link.toString();
            if (linkStr.isNotEmpty) {
              chatLinks.add(linkStr);
            }
          }
        }
        
        if (chat.message != null && chat.message.toString().isNotEmpty) {
          messageType = GroupMessageType.textWithLinks;
          content = chat.message.toString();
          links = chatLinks.isNotEmpty ? chatLinks : null;
        } else if (chatLinks.isNotEmpty) {
          messageType = GroupMessageType.link;
          content = chatLinks.first;
        }
      }
    } catch (e) {
      debugPrint('‚ùå Error determining message type: $e');
      // Fallback to text message
      messageType = GroupMessageType.text;
      content = chat.message?.toString() ?? '';
    }
    
    return {
      'type': messageType,
      'content': content,
      'links': links,
      'pollOptions': pollOptions,
      'additionalText': additionalText,
    };
  }

  /// FIXED: Proper scroll to bottom with timing
  void scrollToBottomAfterLoad() {
    debugPrint('üìú Group Chat - scrollToBottomAfterLoad called, messages: ${messages.length}');
    
    // Allow UI to render first
    WidgetsBinding.instance.addPostFrameCallback((_) {
      // Multiple delayed attempts for better reliability
      Future.delayed(Duration(milliseconds: 100), () {
        if (scrollController.hasClients && messages.isNotEmpty) {
          scrollToBottom(animated: false);
        }
      });
      
      // Second attempt with longer delay
      Future.delayed(Duration(milliseconds: 300), () {
        if (scrollController.hasClients && messages.isNotEmpty) {
          scrollToBottom(animated: false);
        }
      });
      
      // Final attempt
      Future.delayed(Duration(milliseconds: 600), () {
        if (scrollController.hasClients && messages.isNotEmpty) {
          scrollToBottom(animated: false);
        }
      });
    });
  }

  /// FIXED: Scroll to bottom for new messages
  void scrollToBottomForNewMessage() {
    final currentMessageCount = messages.length;
    debugPrint('üìú Group Chat - scrollToBottomForNewMessage called, messages: $currentMessageCount, last: $_lastMessageCount');
    
    // Only scroll if message count actually increased (new message added)
    if (currentMessageCount <= _lastMessageCount) {
      debugPrint('üìú Group Chat - No new messages, skipping auto-scroll');
      return;
    }
    
    _lastMessageCount = currentMessageCount;
    
    // Check if user is already at bottom (within 100px) before scrolling
    if (scrollController.hasClients) {
      final position = scrollController.position;
      final isNearBottom = position.maxScrollExtent - position.pixels < 100;
      
      if (!isNearBottom) {
        debugPrint('üìú Group Chat - User scrolled away from bottom, not auto-scrolling');
        return;
      }
    }
    
    // Immediate scroll for new messages
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (scrollController.hasClients && messages.isNotEmpty) {
        debugPrint('üìú Group Chat - Auto-scrolling to bottom for new message');
        scrollToBottom(animated: true);
      }
    });
  }

  /// Test function for manual scroll
  void testScrollToBottom() {
    debugPrint('üß™ === SCROLL TEST ===');
    debugPrint('üß™ Messages count: ${messages.length}');
    debugPrint('üß™ ScrollController hasClients: ${scrollController.hasClients}');
    if (scrollController.hasClients) {
      debugPrint('üß™ Current position: ${scrollController.position.pixels}');
      debugPrint('üß™ Max extent: ${scrollController.position.maxScrollExtent}');
      debugPrint('üß™ Has content dimensions: ${scrollController.position.hasContentDimensions}');
    }
    debugPrint('üß™ Attempting to scroll...');
    scrollToBottom(animated: true);
    debugPrint('üß™ ==================');
  }

  /// Socket ve listener durumunu kontrol et
  void checkSocketConnection() {
    debugPrint('üîç === GRUP CHAT SOCKET DURUM RAPORU ===');
    debugPrint('üîç Current Group ID: ${currentGroupId.value}');
    debugPrint('üîç Socket Service baƒülƒ±: ${_socketService.isConnected.value}');
    
    // Socket service'den durum kontrol√º yap
    _socketService.checkSocketStatus();
    
    debugPrint('üîç Grup mesaj subscription aktif: ${!_groupMessageSubscription.isPaused}');
    debugPrint('üîç ================================');
  }

  void extractGroupChatMedia() {
    if (groupData.value?.groupChats == null) return;
    
    final groupChats = groupData.value!.groupChats;
    
    // Listeleri temizle
    groupDocuments.clear();
    groupLinks.clear();
    groupPhotos.clear();
    
    for (final chat in groupChats) {
      // Belgeler ve fotoƒüraflar
      for (final media in chat.media) {
        if (media.type.startsWith('image/')) {
          // Fotoƒüraf
          if (!groupPhotos.contains(media.fullPath)) {
            groupPhotos.add(media.fullPath);
          }
        } else {
          // Belge
          final document = DocumentModel(
            id: media.id.toString(),
            name: media.title,
            sizeMb: double.tryParse(media.fileSize) ?? 0.0,
            humanCreatedAt: media.humanCreatedAt,
            createdAt: DateTime.parse(chat.createdAt),
            url: media.fullPath,
          );
          
          // Aynƒ± belgeyi tekrar eklemeyi √∂nle
          if (!groupDocuments.any((doc) => doc.id == document.id)) {
            groupDocuments.add(document);
          }
        }
      }
      
      // Baƒülantƒ±lar
      for (final link in chat.groupChatLink) {
        final linkModel = LinkModel(
          url: link.link,
          title: link.linkTitle,
        );
        
        // Aynƒ± baƒülantƒ±yƒ± tekrar eklemeyi √∂nle
        if (!groupLinks.any((l) => l.url == linkModel.url)) {
          groupLinks.add(linkModel);
        }
      }
    }
    
    // Belgeleri tarihe g√∂re sƒ±rala (en yeni √∂nce)
    groupDocuments.sort((a, b) => b.createdAt.compareTo(a.createdAt));
    
    // Linkleri tarihe g√∂re sƒ±rala (en yeni √∂nce)
    // Link'lerin tarih bilgisi yok, mesaj sƒ±rasƒ±na g√∂re sƒ±rala
    // Bu durumda mesaj sƒ±rasƒ±na g√∂re sƒ±rala (en son eklenen en √ºstte)
    
    // Fotoƒüraflarƒ± tarihe g√∂re sƒ±rala (en yeni √∂nce)
    // Fotoƒüraflar mesaj sƒ±rasƒ±na g√∂re zaten sƒ±ralƒ± geliyor
    
    debugPrint('üìÅ Extracted ${groupDocuments.length} documents from group chats (sorted by date)');
    debugPrint('üîó Extracted ${groupLinks.length} links from group chats');
    debugPrint('üì∏ Extracted ${groupPhotos.length} photos from group chats');
  }

  Future<void> fetchGroupMessages() async {
    try {
      debugPrint('Fetching messages for group: ${currentGroupId.value}');
      
      // Grup verileri zaten y√ºklendi, sadece mesajlarƒ± d√∂n√º≈üt√ºr
      if (groupData.value != null) {
        convertGroupChatsToMessagesOptimized();
      }
      
    } catch (e) {
      debugPrint('Error fetching messages: $e');
      Get.snackbar(languageService.tr("common.error"), languageService.tr("common.messages.messageSendFailed"), snackPosition: SnackPosition.BOTTOM);
    }
  }

  void openPollBottomSheet() {
    pollQuestion.value = '';
    pollOptions.assignAll(['', '']);
    Get.bottomSheet(
      Container(
        padding: const EdgeInsets.all(16),
        decoration: const BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
        ),
        child: SingleChildScrollView(
          keyboardDismissBehavior: ScrollViewKeyboardDismissBehavior.onDrag,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const SizedBox(height: 20),
              TextField(
                style: TextStyle(fontSize: 12),
                controller: pollTitleController,
                decoration: InputDecoration(
                  hintText: languageService.tr("chat.poll.title"),
                  filled: true,
                  fillColor: const Color(0xfff5f5f5),
                  hintStyle:
                      const TextStyle(color: Color(0xFF9CA3AF), fontSize: 12),
                  contentPadding:
                      const EdgeInsets.symmetric(horizontal: 12, vertical: 14),
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(15),
                    borderSide: BorderSide.none,
                  ),
                ),
                onChanged: (val) => pollQuestion.value = val,
              ),
              const SizedBox(height: 30),
              Obx(() => Column(
                    children: List.generate(pollOptions.length, (index) {
                      return Padding(
                        padding: const EdgeInsets.only(bottom: 8.0),
                        child: Row(
                          children: [
                            Expanded(
                              child: TextField(
                                style: TextStyle(fontSize: 12),
                                decoration: InputDecoration(
                                  hintText: languageService.tr("chat.poll.addOption"),
                                  filled: true,
                                  fillColor: const Color(0xfff5f5f5),
                                  hintStyle: const TextStyle(
                                      color: Color(0xFF9CA3AF), fontSize: 12),
                                  contentPadding: const EdgeInsets.symmetric(
                                      horizontal: 12, vertical: 14),
                                  border: OutlineInputBorder(
                                    borderRadius: BorderRadius.circular(15),
                                    borderSide: BorderSide.none,
                                  ),
                                ),
                                onChanged: (val) => pollOptions[index] = val,
                              ),
                            ),
                            const SizedBox(width: 8),
                            if (pollOptions.length > 2)
                              IconButton(
                                icon: const Icon(Icons.remove_circle),
                                onPressed: () => pollOptions.removeAt(index),
                              ),
                          ],
                        ),
                      );
                    }),
                  )),
              TextButton.icon(
                onPressed: () => pollOptions.add(''),
                icon: const Icon(
                  Icons.add,
                  color: Color(0xffED7474),
                  size: 15,
                ),
                label: Text(
                  languageService.tr("chat.poll.addOption"),
                  style: TextStyle(color: Color(0xffED7474), fontSize: 12),
                ),
              ),
              const SizedBox(height: 30),

              /**
               *  backgroundColor: const Color(0xffFFF6F6),
                    foregroundColor: const Color(0xffED7474),
               */
              CustomButton(
                  text: languageService.tr("chat.poll.send"),
                  height: 45,
                  borderRadius: 15,
                  onPressed: () {
                    final filledOptions =
                        pollOptions.where((e) => e.trim().isNotEmpty).toList();
                    if (pollTitleController.text.trim().isNotEmpty &&
                        filledOptions.length >= 2) {
                      sendPoll(pollTitleController.text, filledOptions);
                      Get.back();
                    }
                  },
                  isLoading: isSendingMessage,
                  backgroundColor: Color(0xffFFF6F6),
                  textColor: Color(0xffED7474)),
              const SizedBox(height: 20),
            ],
          ),
        ),
      ),
      isScrollControlled: true,
    );
  }

  void votePoll(String option) {
    if (!pollVotes.containsKey(option)) {
      pollVotes[option] = 1;
    } else {
      pollVotes[option] = pollVotes[option]! + 1;
    }
    selectedPollOption.value = option;
  }

  void sendPoll(String question, List<String> options) async {
    if (isSendingMessage.value) return;
    
    isSendingMessage.value = true;
    
    try {
      // Poll mesajƒ±nƒ± API'ye g√∂nder
      final success = await _groupServices.sendGroupMessage(
        groupId: currentGroupId.value,
        message: question,
        pollOptions: options,
      );
      
      if (success) {
        // Ba≈üarƒ±lƒ± ise mesajlarƒ± yeniden y√ºkle
        await refreshMessagesOnly();
        
        // Poll g√∂nderildikten sonra en alta git
        WidgetsBinding.instance.addPostFrameCallback((_) {
          scrollToBottom(animated: true);
        });
      } else {
        Get.snackbar(
          'Hata',
          'Anket g√∂nderilemedi',
          snackPosition: SnackPosition.BOTTOM,
        );
      }
    } catch (e) {
      debugPrint('Anket g√∂nderme hatasƒ±: $e');
      Get.snackbar(
        'Hata',
        'Anket g√∂nderilemedi',
        snackPosition: SnackPosition.BOTTOM,
      );
    } finally {
      isSendingMessage.value = false;
    }
  }

  void pickImageFromGallery() async {
    final pickedFile =
        await ImagePicker().pickImage(source: ImageSource.gallery);
    if (pickedFile != null) {
      final file = File(pickedFile.path);
      selectedFiles.add(file);
    }
  }

  void pickDocument() async {
    try {
      FilePickerResult? result = await FilePicker.platform.pickFiles(
        type: FileType.custom,
        allowedExtensions: ['pdf', 'doc', 'docx', 'txt'],
      );

      if (result != null && result.files.single.path != null) {
        final filePath = result.files.single.path!;
        final file = File(filePath);
        selectedFiles.add(file);
        
        debugPrint("Se√ßilen dosya: $filePath");
      }
    } catch (e) {
      debugPrint("Belge se√ßme hatasƒ±: $e",wrapWidth: 1024);
    }
  }

  Future<void> sendMessage(String text) async {
    if (isSendingMessage.value) return;
    
    debugPrint('üì§ Sending message: "$text"');
    
    if (text.isEmpty && selectedFiles.isEmpty) {
      debugPrint('‚ùå Nothing to send');
      return;
    }
    
    if (text.isEmpty && selectedFiles.isNotEmpty) {
      debugPrint('üìÅ Sending only media files');
      await sendMediaOnly();
      return;
    }
    
    // Socket durumunu kontrol et
    debugPrint('üîå Socket durumu kontrol ediliyor...');
    debugPrint('üîå Socket baƒülƒ±: ${_socketService.isConnected.value}');
    debugPrint('üîå Socket ID: ${_socketService.socket?.id}');
    debugPrint('üîå Group Message Subscription aktif: ${!_groupMessageSubscription.isPaused}');
    
    isSendingMessage.value = true;
    
    try {
      bool success;
      
      if (text.isNotEmpty && hasLinksInText(text)) {
        debugPrint('üîó Links detected in text, processing...');
        
        final urls = extractUrlsFromText(text);
        final nonLinkText = extractNonLinkText(text);
        final normalizedUrls = urls.map((url) => normalizeUrl(url)).toList();
        
        success = await _groupServices.sendGroupMessage(
          groupId: currentGroupId.value,
          message: nonLinkText,
          mediaFiles: selectedFiles.isNotEmpty ? selectedFiles : null,
          links: normalizedUrls,
        );
      } else {
        success = await _groupServices.sendGroupMessage(
          groupId: currentGroupId.value,
          message: text,
          mediaFiles: selectedFiles.isNotEmpty ? selectedFiles : null,
          links: null,
        );
      }
      
      if (success) {
        selectedFiles.clear();
        
        // Socket √ºzerinden mesaj gelip gelmediƒüini kontrol et
        debugPrint('‚úÖ Mesaj ba≈üarƒ±yla g√∂nderildi, socket √ºzerinden gelmesi bekleniyor...');
        
        // Socket √ºzerinden mesaj gelmesi i√ßin kƒ±sa bir s√ºre bekle
        bool socketMessageReceived = false;
        final originalMessageCount = messages.length;
        
        // 2 saniye boyunca socket mesajƒ±nƒ± bekle
        for (int i = 0; i < 20; i++) {
          await Future.delayed(Duration(milliseconds: 100));
          if (messages.length > originalMessageCount) {
            debugPrint('‚úÖ Socket √ºzerinden yeni mesaj geldi!');
            socketMessageReceived = true;
            break;
          }
        }
        
        if (!socketMessageReceived) {
          debugPrint('‚ö†Ô∏è Socket √ºzerinden mesaj gelmedi, API\'den yeniden y√ºklenecek...');
        }
        
        // FIXED: Immediate scroll for better UX, then refresh
        scrollToBottomForNewMessage();
        
        // OPTIMIZE: Reduced refresh delay
        Future.delayed(Duration(milliseconds: 300), () async {
          await refreshMessagesOptimized();
          // Ensure we stay at bottom after refresh
          scrollToBottomForNewMessage();
        });
      } else {
        Get.snackbar(languageService.tr("common.error"), languageService.tr("common.messages.messageSendFailed"), snackPosition: SnackPosition.BOTTOM);
      }
      
    } catch (e) {
      debugPrint('üí• Message sending error: $e');
      Get.snackbar(languageService.tr("common.error"), languageService.tr("common.messages.messageSendFailed"), snackPosition: SnackPosition.BOTTOM);
    } finally {
      isSendingMessage.value = false;
    }
  }

  // Sadece media dosyalarƒ±nƒ± g√∂nder (text olmadan)
  Future<void> sendMediaOnly() async {
    if (isSendingMessage.value) return;
    
    debugPrint('üìÅ Sending media files only');
    isSendingMessage.value = true;
    
    try {
      final success = await _groupServices.sendGroupMessage(
        groupId: currentGroupId.value,
        message: '', // Bo≈ü text
        mediaFiles: selectedFiles,
        links: null,
      );
      
      if (success) {
        selectedFiles.clear();
        
        // FIXED: Same scroll behavior for media
        scrollToBottomForNewMessage();
        
        Future.delayed(Duration(milliseconds: 300), () async {
          await refreshMessagesOptimized();
          scrollToBottomForNewMessage();
        });
      } else {
        Get.snackbar(languageService.tr("common.error"), languageService.tr("common.messages.mediaSendFailed"), snackPosition: SnackPosition.BOTTOM);
      }
      
    } catch (e) {
      debugPrint('üí• Media sending error: $e');
      Get.snackbar(languageService.tr("common.error"), languageService.tr("common.messages.mediaSendFailed"), snackPosition: SnackPosition.BOTTOM);
    } finally {
      isSendingMessage.value = false;
    }
  }

  void clearSelectedItems() {
    selectedFiles.clear();
  }

  void scrollToBottom({bool animated = true}) {
    try {
      if (scrollController.hasClients && 
          scrollController.position.hasContentDimensions &&
          messages.isNotEmpty) {
        
        final maxScroll = scrollController.position.maxScrollExtent;
        debugPrint('üìú Group Chat - Scrolling to bottom: maxScroll = $maxScroll');
        
        if (animated) {
          scrollController.animateTo(
            maxScroll,
            duration: Duration(milliseconds: 300),
            curve: Curves.easeOut,
          );
        } else {
          scrollController.jumpTo(maxScroll);
        }
      } else {
        debugPrint('‚ö†Ô∏è Group Chat - Cannot scroll: hasClients=${scrollController.hasClients}, messages=${messages.length}');
      }
    } catch (e) {
      debugPrint('‚ùå Group Chat - Scroll error: $e');
    }
  }

  void getToGrupDetailScreen() {
    debugPrint('üîç Navigating to group detail screen with group ID: ${currentGroupId.value}');
    Get.toNamed("/groupDetailScreen", arguments: {
      'groupId': currentGroupId.value,
    });
  }

  // OPTIMIZE: Faster message refresh
  Future<void> refreshMessagesOptimized() async {
    try {
      debugPrint('üîÑ Refreshing messages (optimized)...');
      
      // Reduced timeout for faster response
      final group = await _groupServices.fetchGroupDetail(currentGroupId.value)
          .timeout(const Duration(seconds: 5));
      
      groupData.value = group;
      convertGroupChatsToMessagesOptimized();
      
      debugPrint('‚úÖ Messages refreshed successfully');
    } catch (e) {
      debugPrint('‚ùå Error refreshing messages: $e');
    }
  }

  // Keep backwards compatibility
  Future<void> refreshMessagesOnly() async {
    await refreshMessagesOptimized();
  }

  @override
  void onClose() {
    // Chat liste controller'ƒ±n group message listener'ƒ±nƒ± tekrar ba≈ülat
    try {
      final chatController = Get.find<ChatController>();
      chatController.resumeGroupMessageListener();
      debugPrint('‚ñ∂Ô∏è ChatController group message listener tekrar ba≈ülatƒ±ldƒ±');
    } catch (e) {
      debugPrint('‚ö†Ô∏è ChatController resume edilemedi: $e');
    }
    
    // Socket listener guard'ƒ± reset et
    _isSocketListenerSetup = false;
    
    messageController.dispose();
    pollTitleController.dispose();
    scrollController.dispose();
    _groupMessageSubscription.cancel();
    _userCache.clear(); // Clear cache
    _lastMessageCount = 0; // Reset message count tracker
    super.onClose();
  }
}
